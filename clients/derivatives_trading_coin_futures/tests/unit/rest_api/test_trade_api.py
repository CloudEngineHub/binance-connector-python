"""
Binance Derivatives Trading COIN Futures REST API

OpenAPI Specification for the Binance Derivatives Trading COIN Futures REST API
The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import pytest
import requests

from unittest.mock import MagicMock, patch
from urllib.parse import parse_qs

from binance_common.configuration import ConfigurationRestAPI
from binance_common.errors import RequiredError
from binance_common.utils import normalize_query_values, is_one_of_model, snake_to_camel

from binance_sdk_derivatives_trading_coin_futures.rest_api.api import TradeApi
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    AccountTradeListResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    AllOrdersResponse,
)

from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    CancelAllOpenOrdersResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    CancelMultipleOrdersResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    CancelOrderResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    ChangeInitialLeverageResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    ChangeMarginTypeResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    ChangePositionModeResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    CurrentAllOpenOrdersResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    GetOrderModifyHistoryResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    GetPositionMarginChangeHistoryResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    ModifyIsolatedPositionMarginResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    ModifyMultipleOrdersResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    ModifyOrderResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    NewOrderResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    PositionAdlQuantileEstimationResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    PositionInformationResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    QueryCurrentOpenOrderResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    QueryOrderResponse,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    UsersForceOrdersResponse,
)


from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    ChangeMarginTypeMarginTypeEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    ModifyIsolatedPositionMarginTypeEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    ModifyIsolatedPositionMarginPositionSideEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    ModifyOrderSideEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    ModifyOrderPriceMatchEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    NewOrderSideEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    NewOrderTypeEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    NewOrderPositionSideEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    NewOrderTimeInForceEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    NewOrderWorkingTypeEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    NewOrderNewOrderRespTypeEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    NewOrderPriceMatchEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    NewOrderSelfTradePreventionModeEnum,
)
from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    UsersForceOrdersAutoCloseTypeEnum,
)

from binance_sdk_derivatives_trading_coin_futures.rest_api.models import (
    ModifyMultipleOrdersBatchOrdersParameterInner,
)


class TestTradeApi:
    @pytest.fixture(autouse=True)
    def setup_client(self):
        """Setup a client instance with mocked session before each test method."""
        self.mock_session = MagicMock(spec=requests.Session)
        config = ConfigurationRestAPI(
            api_key="test-api-key",
            api_secret="test-api-secret",
        )
        self.client = TradeApi(configuration=config, session=self.mock_session)

    def set_mock_response(self, data: dict = {}, status_code=200, headers=None):
        """Helper method to setup mock response for the client's session request."""
        if headers is None:
            headers = {}

        mock_response = MagicMock()
        mock_response.status_code = status_code
        mock_response.json.return_value = data
        mock_response.text = json.dumps(data)
        mock_response.headers = headers

        self.mock_session.request.return_value = mock_response

    @patch("binance_common.utils.get_signature")
    def test_account_trade_list_success(self, mock_get_signature):
        """Test account_trade_list() successfully with required parameters only."""

        expected_response = [
            {
                "symbol": "BTCUSD_200626",
                "id": 6,
                "orderId": 28,
                "pair": "BTCUSD",
                "side": "SELL",
                "price": "8800",
                "qty": "1",
                "realizedPnl": "0",
                "marginAsset": "BTC",
                "baseQty": "0.01136364",
                "commission": "0.00000454",
                "commissionAsset": "BTC",
                "time": 1590743483586,
                "positionSide": "BOTH",
                "buyer": False,
                "maker": False,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.account_trade_list()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/userTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(AccountTradeListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(AccountTradeListResponse, "from_dict"):
            expected = AccountTradeListResponse.from_dict(expected_response)
        else:
            expected = AccountTradeListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_account_trade_list_success_with_optional_params(self, mock_get_signature):
        """Test account_trade_list() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "pair": "pair_example",
            "order_id": "1",
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "from_id": 1,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "symbol": "BTCUSD_200626",
                "id": 6,
                "orderId": 28,
                "pair": "BTCUSD",
                "side": "SELL",
                "price": "8800",
                "qty": "1",
                "realizedPnl": "0",
                "marginAsset": "BTC",
                "baseQty": "0.01136364",
                "commission": "0.00000454",
                "commissionAsset": "BTC",
                "time": 1590743483586,
                "positionSide": "BOTH",
                "buyer": False,
                "maker": False,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.account_trade_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/userTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(AccountTradeListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(AccountTradeListResponse, "from_dict"):
            expected = AccountTradeListResponse.from_dict(expected_response)
        else:
            expected = AccountTradeListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_account_trade_list_server_error(self):
        """Test that account_trade_list() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.account_trade_list = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.account_trade_list()

    @patch("binance_common.utils.get_signature")
    def test_all_orders_success(self, mock_get_signature):
        """Test all_orders() successfully with required parameters only."""

        expected_response = [
            {
                "avgPrice": "0.0",
                "clientOrderId": "abc",
                "cumBase": "0",
                "executedQty": "0",
                "orderId": 1917641,
                "origQty": "0.40",
                "origType": "TRAILING_STOP_MARKET",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "stopPrice": "9300",
                "closePosition": False,
                "symbol": "BTCUSD_200925",
                "pair": "BTCUSD",
                "time": 1579276756075,
                "timeInForce": "GTC",
                "type": "TRAILING_STOP_MARKET",
                "activatePrice": "9020",
                "priceRate": "0.3",
                "updateTime": 1579276756075,
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.all_orders()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/allOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(AllOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(AllOrdersResponse, "from_dict"):
            expected = AllOrdersResponse.from_dict(expected_response)
        else:
            expected = AllOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_all_orders_success_with_optional_params(self, mock_get_signature):
        """Test all_orders() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "pair": "pair_example",
            "order_id": 1,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "avgPrice": "0.0",
                "clientOrderId": "abc",
                "cumBase": "0",
                "executedQty": "0",
                "orderId": 1917641,
                "origQty": "0.40",
                "origType": "TRAILING_STOP_MARKET",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "stopPrice": "9300",
                "closePosition": False,
                "symbol": "BTCUSD_200925",
                "pair": "BTCUSD",
                "time": 1579276756075,
                "timeInForce": "GTC",
                "type": "TRAILING_STOP_MARKET",
                "activatePrice": "9020",
                "priceRate": "0.3",
                "updateTime": 1579276756075,
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.all_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/allOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(AllOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(AllOrdersResponse, "from_dict"):
            expected = AllOrdersResponse.from_dict(expected_response)
        else:
            expected = AllOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_all_orders_server_error(self):
        """Test that all_orders() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.all_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.all_orders()

    @patch("binance_common.utils.get_signature")
    def test_auto_cancel_all_open_orders_success(self, mock_get_signature):
        """Test auto_cancel_all_open_orders() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "countdown_time": 56,
        }

        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response({})

        response = self.client.auto_cancel_all_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/countdownCancelAll" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["countdownTime"] == 56

        assert response is not None

        assert response.data() == {}

    @patch("binance_common.utils.get_signature")
    def test_auto_cancel_all_open_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test auto_cancel_all_open_orders() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "countdown_time": 56, "recv_window": 5000}

        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response({})

        response = self.client.auto_cancel_all_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/countdownCancelAll" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None

        assert response.data() == {}

    def test_auto_cancel_all_open_orders_missing_required_param_symbol(self):
        """Test that auto_cancel_all_open_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "countdown_time": 56,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.auto_cancel_all_open_orders(**params)

    def test_auto_cancel_all_open_orders_missing_required_param_countdown_time(self):
        """Test that auto_cancel_all_open_orders() raises RequiredError when 'countdown_time' is missing."""
        params = {
            "symbol": "symbol_example",
            "countdown_time": 56,
        }
        params["countdown_time"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'countdown_time'"
        ):
            self.client.auto_cancel_all_open_orders(**params)

    def test_auto_cancel_all_open_orders_server_error(self):
        """Test that auto_cancel_all_open_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "countdown_time": 56,
        }

        mock_error = Exception("ResponseError")
        self.client.auto_cancel_all_open_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.auto_cancel_all_open_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_cancel_all_open_orders_success(self, mock_get_signature):
        """Test cancel_all_open_orders() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "code": 200,
            "msg": "The operation of cancel all open order is done.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_all_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/allOpenOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelAllOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelAllOpenOrdersResponse, "from_dict"):
            expected = CancelAllOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = CancelAllOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_all_open_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test cancel_all_open_orders() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = {
            "code": 200,
            "msg": "The operation of cancel all open order is done.",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_all_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/allOpenOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelAllOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelAllOpenOrdersResponse, "from_dict"):
            expected = CancelAllOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = CancelAllOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_all_open_orders_missing_required_param_symbol(self):
        """Test that cancel_all_open_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_all_open_orders(**params)

    def test_cancel_all_open_orders_server_error(self):
        """Test that cancel_all_open_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_all_open_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_all_open_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_cancel_multiple_orders_success(self, mock_get_signature):
        """Test cancel_multiple_orders() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "avgPrice": "0.0",
                "clientOrderId": "myOrder1",
                "cumQty": "0",
                "cumBase": "0",
                "executedQty": "0",
                "orderId": 283194212,
                "origQty": "11",
                "origType": "TRAILING_STOP_MARKET",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "CANCELED",
                "stopPrice": "9300",
                "closePosition": False,
                "symbol": "BTCUSD_200925",
                "timeInForce": "GTC",
                "type": "TRAILING_STOP_MARKET",
                "activatePrice": "9020",
                "priceRate": "0.3",
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
                "updateTime": 1571110484038,
            },
            {"code": -2011, "msg": "Unknown order sent."},
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_multiple_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/batchOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelMultipleOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelMultipleOrdersResponse, "from_dict"):
            expected = CancelMultipleOrdersResponse.from_dict(expected_response)
        else:
            expected = CancelMultipleOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_multiple_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test cancel_multiple_orders() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id_list": [1234567],
            "orig_client_order_id_list": ["my_id_1"],
            "recv_window": 5000,
        }

        expected_response = [
            {
                "avgPrice": "0.0",
                "clientOrderId": "myOrder1",
                "cumQty": "0",
                "cumBase": "0",
                "executedQty": "0",
                "orderId": 283194212,
                "origQty": "11",
                "origType": "TRAILING_STOP_MARKET",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "CANCELED",
                "stopPrice": "9300",
                "closePosition": False,
                "symbol": "BTCUSD_200925",
                "timeInForce": "GTC",
                "type": "TRAILING_STOP_MARKET",
                "activatePrice": "9020",
                "priceRate": "0.3",
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
                "updateTime": 1571110484038,
            },
            {"code": -2011, "msg": "Unknown order sent."},
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_multiple_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/batchOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelMultipleOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelMultipleOrdersResponse, "from_dict"):
            expected = CancelMultipleOrdersResponse.from_dict(expected_response)
        else:
            expected = CancelMultipleOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_multiple_orders_missing_required_param_symbol(self):
        """Test that cancel_multiple_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_multiple_orders(**params)

    def test_cancel_multiple_orders_server_error(self):
        """Test that cancel_multiple_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_multiple_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_multiple_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_cancel_order_success(self, mock_get_signature):
        """Test cancel_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "avgPrice": "0.0",
            "clientOrderId": "myOrder1",
            "cumQty": "0",
            "cumBase": "0",
            "executedQty": "0",
            "orderId": 283194212,
            "origQty": "11",
            "origType": "TRAILING_STOP_MARKET",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "CANCELED",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "timeInForce": "GTC",
            "type": "TRAILING_STOP_MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "updateTime": 1571110484038,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelOrderResponse, "from_dict"):
            expected = CancelOrderResponse.from_dict(expected_response)
        else:
            expected = CancelOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_cancel_order_success_with_optional_params(self, mock_get_signature):
        """Test cancel_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "avgPrice": "0.0",
            "clientOrderId": "myOrder1",
            "cumQty": "0",
            "cumBase": "0",
            "executedQty": "0",
            "orderId": 283194212,
            "origQty": "11",
            "origType": "TRAILING_STOP_MARKET",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "CANCELED",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "timeInForce": "GTC",
            "type": "TRAILING_STOP_MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "updateTime": 1571110484038,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.cancel_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "DELETE"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CancelOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CancelOrderResponse, "from_dict"):
            expected = CancelOrderResponse.from_dict(expected_response)
        else:
            expected = CancelOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_cancel_order_missing_required_param_symbol(self):
        """Test that cancel_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.cancel_order(**params)

    def test_cancel_order_server_error(self):
        """Test that cancel_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.cancel_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.cancel_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_change_initial_leverage_success(self, mock_get_signature):
        """Test change_initial_leverage() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "leverage": 56,
        }

        expected_response = {
            "leverage": 21,
            "maxQty": "1000",
            "symbol": "BTCUSD_200925",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.change_initial_leverage(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/leverage" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["leverage"] == 56

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ChangeInitialLeverageResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ChangeInitialLeverageResponse, "from_dict"):
            expected = ChangeInitialLeverageResponse.from_dict(expected_response)
        else:
            expected = ChangeInitialLeverageResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_change_initial_leverage_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test change_initial_leverage() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "leverage": 56, "recv_window": 5000}

        expected_response = {
            "leverage": 21,
            "maxQty": "1000",
            "symbol": "BTCUSD_200925",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.change_initial_leverage(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/leverage" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ChangeInitialLeverageResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ChangeInitialLeverageResponse, "from_dict"):
            expected = ChangeInitialLeverageResponse.from_dict(expected_response)
        else:
            expected = ChangeInitialLeverageResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_change_initial_leverage_missing_required_param_symbol(self):
        """Test that change_initial_leverage() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "leverage": 56,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.change_initial_leverage(**params)

    def test_change_initial_leverage_missing_required_param_leverage(self):
        """Test that change_initial_leverage() raises RequiredError when 'leverage' is missing."""
        params = {
            "symbol": "symbol_example",
            "leverage": 56,
        }
        params["leverage"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'leverage'"
        ):
            self.client.change_initial_leverage(**params)

    def test_change_initial_leverage_server_error(self):
        """Test that change_initial_leverage() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "leverage": 56,
        }

        mock_error = Exception("ResponseError")
        self.client.change_initial_leverage = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.change_initial_leverage(**params)

    @patch("binance_common.utils.get_signature")
    def test_change_margin_type_success(self, mock_get_signature):
        """Test change_margin_type() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "margin_type": ChangeMarginTypeMarginTypeEnum["ISOLATED"].value,
        }

        expected_response = {"code": 200, "msg": "success"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.change_margin_type(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/marginType" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "symbol_example"
        assert (
            normalized["marginType"] == ChangeMarginTypeMarginTypeEnum["ISOLATED"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ChangeMarginTypeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ChangeMarginTypeResponse, "from_dict"):
            expected = ChangeMarginTypeResponse.from_dict(expected_response)
        else:
            expected = ChangeMarginTypeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_change_margin_type_success_with_optional_params(self, mock_get_signature):
        """Test change_margin_type() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "margin_type": ChangeMarginTypeMarginTypeEnum["ISOLATED"].value,
            "recv_window": 5000,
        }

        expected_response = {"code": 200, "msg": "success"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.change_margin_type(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/marginType" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ChangeMarginTypeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ChangeMarginTypeResponse, "from_dict"):
            expected = ChangeMarginTypeResponse.from_dict(expected_response)
        else:
            expected = ChangeMarginTypeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_change_margin_type_missing_required_param_symbol(self):
        """Test that change_margin_type() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "margin_type": ChangeMarginTypeMarginTypeEnum["ISOLATED"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.change_margin_type(**params)

    def test_change_margin_type_missing_required_param_margin_type(self):
        """Test that change_margin_type() raises RequiredError when 'margin_type' is missing."""
        params = {
            "symbol": "symbol_example",
            "margin_type": ChangeMarginTypeMarginTypeEnum["ISOLATED"].value,
        }
        params["margin_type"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'margin_type'"
        ):
            self.client.change_margin_type(**params)

    def test_change_margin_type_server_error(self):
        """Test that change_margin_type() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "margin_type": ChangeMarginTypeMarginTypeEnum["ISOLATED"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.change_margin_type = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.change_margin_type(**params)

    @patch("binance_common.utils.get_signature")
    def test_change_position_mode_success(self, mock_get_signature):
        """Test change_position_mode() successfully with required parameters only."""

        params = {
            "dual_side_position": "dual_side_position_example",
        }

        expected_response = {"code": 200, "msg": "success"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.change_position_mode(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/positionSide/dual" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["dualSidePosition"] == "dual_side_position_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ChangePositionModeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ChangePositionModeResponse, "from_dict"):
            expected = ChangePositionModeResponse.from_dict(expected_response)
        else:
            expected = ChangePositionModeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_change_position_mode_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test change_position_mode() successfully with optional parameters."""

        params = {
            "dual_side_position": "dual_side_position_example",
            "recv_window": 5000,
        }

        expected_response = {"code": 200, "msg": "success"}
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.change_position_mode(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/positionSide/dual" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ChangePositionModeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ChangePositionModeResponse, "from_dict"):
            expected = ChangePositionModeResponse.from_dict(expected_response)
        else:
            expected = ChangePositionModeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_change_position_mode_missing_required_param_dual_side_position(self):
        """Test that change_position_mode() raises RequiredError when 'dual_side_position' is missing."""
        params = {
            "dual_side_position": "dual_side_position_example",
        }
        params["dual_side_position"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'dual_side_position'"
        ):
            self.client.change_position_mode(**params)

    def test_change_position_mode_server_error(self):
        """Test that change_position_mode() raises an error when the server returns an error."""

        params = {
            "dual_side_position": "dual_side_position_example",
        }

        mock_error = Exception("ResponseError")
        self.client.change_position_mode = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.change_position_mode(**params)

    @patch("binance_common.utils.get_signature")
    def test_current_all_open_orders_success(self, mock_get_signature):
        """Test current_all_open_orders() successfully with required parameters only."""

        expected_response = [
            {
                "avgPrice": "0.0",
                "clientOrderId": "abc",
                "cumBase": "0",
                "executedQty": "0",
                "orderId": 1917641,
                "origQty": "0.40",
                "origType": "TRAILING_STOP_MARKET",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "stopPrice": "9300",
                "closePosition": False,
                "symbol": "BTCUSD_200925",
                "time": 1579276756075,
                "timeInForce": "GTC",
                "type": "TRAILING_STOP_MARKET",
                "activatePrice": "9020",
                "priceRate": "0.3",
                "updateTime": 1579276756075,
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.current_all_open_orders()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CurrentAllOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CurrentAllOpenOrdersResponse, "from_dict"):
            expected = CurrentAllOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = CurrentAllOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_current_all_open_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test current_all_open_orders() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "pair": "pair_example",
            "recv_window": 5000,
        }

        expected_response = [
            {
                "avgPrice": "0.0",
                "clientOrderId": "abc",
                "cumBase": "0",
                "executedQty": "0",
                "orderId": 1917641,
                "origQty": "0.40",
                "origType": "TRAILING_STOP_MARKET",
                "price": "0",
                "reduceOnly": False,
                "side": "BUY",
                "positionSide": "SHORT",
                "status": "NEW",
                "stopPrice": "9300",
                "closePosition": False,
                "symbol": "BTCUSD_200925",
                "time": 1579276756075,
                "timeInForce": "GTC",
                "type": "TRAILING_STOP_MARKET",
                "activatePrice": "9020",
                "priceRate": "0.3",
                "updateTime": 1579276756075,
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.current_all_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CurrentAllOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CurrentAllOpenOrdersResponse, "from_dict"):
            expected = CurrentAllOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = CurrentAllOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_current_all_open_orders_server_error(self):
        """Test that current_all_open_orders() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.current_all_open_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.current_all_open_orders()

    @patch("binance_common.utils.get_signature")
    def test_get_order_modify_history_success(self, mock_get_signature):
        """Test get_order_modify_history() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "amendmentId": 5363,
                "symbol": "BTCUSD_PERP",
                "pair": "BTCUSD",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629184560899,
                "amendment": {
                    "price": {"before": "30004", "after": "30003.2"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 3,
                },
            },
            {
                "amendmentId": 5361,
                "symbol": "BTCUSD_PERP",
                "pair": "BTCUSD",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629184533946,
                "amendment": {
                    "price": {"before": "30005", "after": "30004"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 2,
                },
            },
            {
                "amendmentId": 5325,
                "symbol": "BTCUSD_PERP",
                "pair": "BTCUSD",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629182711787,
                "amendment": {
                    "price": {"before": "30002", "after": "30005"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 1,
                },
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_order_modify_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/orderAmendment" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetOrderModifyHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(GetOrderModifyHistoryResponse, "from_dict"):
            expected = GetOrderModifyHistoryResponse.from_dict(expected_response)
        else:
            expected = GetOrderModifyHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_order_modify_history_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test get_order_modify_history() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "amendmentId": 5363,
                "symbol": "BTCUSD_PERP",
                "pair": "BTCUSD",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629184560899,
                "amendment": {
                    "price": {"before": "30004", "after": "30003.2"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 3,
                },
            },
            {
                "amendmentId": 5361,
                "symbol": "BTCUSD_PERP",
                "pair": "BTCUSD",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629184533946,
                "amendment": {
                    "price": {"before": "30005", "after": "30004"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 2,
                },
            },
            {
                "amendmentId": 5325,
                "symbol": "BTCUSD_PERP",
                "pair": "BTCUSD",
                "orderId": 20072994037,
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "time": 1629182711787,
                "amendment": {
                    "price": {"before": "30002", "after": "30005"},
                    "origQty": {"before": "1", "after": "1"},
                    "count": 1,
                },
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_order_modify_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/orderAmendment" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetOrderModifyHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(GetOrderModifyHistoryResponse, "from_dict"):
            expected = GetOrderModifyHistoryResponse.from_dict(expected_response)
        else:
            expected = GetOrderModifyHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_order_modify_history_missing_required_param_symbol(self):
        """Test that get_order_modify_history() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.get_order_modify_history(**params)

    def test_get_order_modify_history_server_error(self):
        """Test that get_order_modify_history() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.get_order_modify_history = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_order_modify_history(**params)

    @patch("binance_common.utils.get_signature")
    def test_get_position_margin_change_history_success(self, mock_get_signature):
        """Test get_position_margin_change_history() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "amount": "23.36332311",
                "asset": "BTC",
                "symbol": "BTCUSD_200925",
                "time": 1578047897183,
                "type": 1,
                "positionSide": "BOTH",
            },
            {
                "amount": "100",
                "asset": "BTC",
                "symbol": "BTCUSD_200925",
                "time": 1578047900425,
                "type": 1,
                "positionSide": "LONG",
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_position_margin_change_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/positionMargin/history" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetPositionMarginChangeHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetPositionMarginChangeHistoryResponse, "from_dict")
        ):
            expected = GetPositionMarginChangeHistoryResponse.from_dict(
                expected_response
            )
        else:
            expected = GetPositionMarginChangeHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_position_margin_change_history_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test get_position_margin_change_history() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "type": 56,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "amount": "23.36332311",
                "asset": "BTC",
                "symbol": "BTCUSD_200925",
                "time": 1578047897183,
                "type": 1,
                "positionSide": "BOTH",
            },
            {
                "amount": "100",
                "asset": "BTC",
                "symbol": "BTCUSD_200925",
                "time": 1578047900425,
                "type": 1,
                "positionSide": "LONG",
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_position_margin_change_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/positionMargin/history" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetPositionMarginChangeHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(GetPositionMarginChangeHistoryResponse, "from_dict")
        ):
            expected = GetPositionMarginChangeHistoryResponse.from_dict(
                expected_response
            )
        else:
            expected = GetPositionMarginChangeHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_position_margin_change_history_missing_required_param_symbol(self):
        """Test that get_position_margin_change_history() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.get_position_margin_change_history(**params)

    def test_get_position_margin_change_history_server_error(self):
        """Test that get_position_margin_change_history() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.get_position_margin_change_history = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_position_margin_change_history(**params)

    @patch("binance_common.utils.get_signature")
    def test_modify_isolated_position_margin_success(self, mock_get_signature):
        """Test modify_isolated_position_margin() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "amount": 1.0,
            "type": ModifyIsolatedPositionMarginTypeEnum["LIMIT"].value,
        }

        expected_response = {
            "amount": 100,
            "code": 200,
            "msg": "Successfully modify position margin.",
            "type": 1,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.modify_isolated_position_margin(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/positionMargin" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["amount"] == 1.0
        assert normalized["type"] == ModifyIsolatedPositionMarginTypeEnum["LIMIT"].value

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ModifyIsolatedPositionMarginResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(ModifyIsolatedPositionMarginResponse, "from_dict")
        ):
            expected = ModifyIsolatedPositionMarginResponse.from_dict(expected_response)
        else:
            expected = ModifyIsolatedPositionMarginResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_modify_isolated_position_margin_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test modify_isolated_position_margin() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "amount": 1.0,
            "type": ModifyIsolatedPositionMarginTypeEnum["LIMIT"].value,
            "position_side": ModifyIsolatedPositionMarginPositionSideEnum["BOTH"].value,
            "recv_window": 5000,
        }

        expected_response = {
            "amount": 100,
            "code": 200,
            "msg": "Successfully modify position margin.",
            "type": 1,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.modify_isolated_position_margin(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/positionMargin" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ModifyIsolatedPositionMarginResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(ModifyIsolatedPositionMarginResponse, "from_dict")
        ):
            expected = ModifyIsolatedPositionMarginResponse.from_dict(expected_response)
        else:
            expected = ModifyIsolatedPositionMarginResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_modify_isolated_position_margin_missing_required_param_symbol(self):
        """Test that modify_isolated_position_margin() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "amount": 1.0,
            "type": ModifyIsolatedPositionMarginTypeEnum["LIMIT"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.modify_isolated_position_margin(**params)

    def test_modify_isolated_position_margin_missing_required_param_amount(self):
        """Test that modify_isolated_position_margin() raises RequiredError when 'amount' is missing."""
        params = {
            "symbol": "symbol_example",
            "amount": 1.0,
            "type": ModifyIsolatedPositionMarginTypeEnum["LIMIT"].value,
        }
        params["amount"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'amount'"):
            self.client.modify_isolated_position_margin(**params)

    def test_modify_isolated_position_margin_missing_required_param_type(self):
        """Test that modify_isolated_position_margin() raises RequiredError when 'type' is missing."""
        params = {
            "symbol": "symbol_example",
            "amount": 1.0,
            "type": ModifyIsolatedPositionMarginTypeEnum["LIMIT"].value,
        }
        params["type"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'type'"):
            self.client.modify_isolated_position_margin(**params)

    def test_modify_isolated_position_margin_server_error(self):
        """Test that modify_isolated_position_margin() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "amount": 1.0,
            "type": ModifyIsolatedPositionMarginTypeEnum["LIMIT"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.modify_isolated_position_margin = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.modify_isolated_position_margin(**params)

    @patch("binance_common.utils.get_signature")
    def test_modify_multiple_orders_success(self, mock_get_signature):
        """Test modify_multiple_orders() successfully with required parameters only."""

        params = {
            "batch_orders": [
                ModifyMultipleOrdersBatchOrdersParameterInner(
                    order_id=1,
                    orig_client_order_id="1",
                    symbol="",
                    side="BUY",
                    quantity=1.0,
                    price=1.0,
                    recv_window=5000,
                )
            ],
        }

        expected_response = [
            {
                "orderId": 20072994037,
                "symbol": "BTCUSD_PERP",
                "pair": "BTCUSD",
                "status": "NEW",
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "price": "30005",
                "avgPrice": "0.0",
                "origQty": "1",
                "executedQty": "0",
                "cumQty": "0",
                "cumBase": "0",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "reduceOnly": False,
                "closePosition": False,
                "side": "BUY",
                "positionSide": "LONG",
                "stopPrice": "0",
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "origType": "LIMIT",
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
                "updateTime": 1629182711600,
            },
            {"code": -2022, "msg": "ReduceOnly Order is rejected."},
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.modify_multiple_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/batchOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "PUT"
        assert "batchOrders" in normalized

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ModifyMultipleOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ModifyMultipleOrdersResponse, "from_dict"):
            expected = ModifyMultipleOrdersResponse.from_dict(expected_response)
        else:
            expected = ModifyMultipleOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_modify_multiple_orders_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test modify_multiple_orders() successfully with optional parameters."""

        params = {
            "batch_orders": [
                ModifyMultipleOrdersBatchOrdersParameterInner(
                    order_id=1,
                    orig_client_order_id="1",
                    symbol="",
                    side="BUY",
                    quantity=1.0,
                    price=1.0,
                    recv_window=5000,
                )
            ],
            "recv_window": 5000,
        }

        expected_response = [
            {
                "orderId": 20072994037,
                "symbol": "BTCUSD_PERP",
                "pair": "BTCUSD",
                "status": "NEW",
                "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
                "price": "30005",
                "avgPrice": "0.0",
                "origQty": "1",
                "executedQty": "0",
                "cumQty": "0",
                "cumBase": "0",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "reduceOnly": False,
                "closePosition": False,
                "side": "BUY",
                "positionSide": "LONG",
                "stopPrice": "0",
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "origType": "LIMIT",
                "priceMatch": "NONE",
                "selfTradePreventionMode": "NONE",
                "updateTime": 1629182711600,
            },
            {"code": -2022, "msg": "ReduceOnly Order is rejected."},
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.modify_multiple_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/batchOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "PUT"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ModifyMultipleOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ModifyMultipleOrdersResponse, "from_dict"):
            expected = ModifyMultipleOrdersResponse.from_dict(expected_response)
        else:
            expected = ModifyMultipleOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_modify_multiple_orders_missing_required_param_batch_orders(self):
        """Test that modify_multiple_orders() raises RequiredError when 'batch_orders' is missing."""
        params = {
            "batch_orders": [
                ModifyMultipleOrdersBatchOrdersParameterInner(
                    order_id=1,
                    orig_client_order_id="1",
                    symbol="",
                    side="BUY",
                    quantity=1.0,
                    price=1.0,
                    recv_window=5000,
                )
            ],
        }
        params["batch_orders"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'batch_orders'"
        ):
            self.client.modify_multiple_orders(**params)

    def test_modify_multiple_orders_server_error(self):
        """Test that modify_multiple_orders() raises an error when the server returns an error."""

        params = {
            "batch_orders": [
                ModifyMultipleOrdersBatchOrdersParameterInner(
                    order_id=1,
                    orig_client_order_id="1",
                    symbol="",
                    side="BUY",
                    quantity=1.0,
                    price=1.0,
                    recv_window=5000,
                )
            ],
        }

        mock_error = Exception("ResponseError")
        self.client.modify_multiple_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.modify_multiple_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_modify_order_success(self, mock_get_signature):
        """Test modify_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "side": ModifyOrderSideEnum["BUY"].value,
        }

        expected_response = {
            "orderId": 20072994037,
            "symbol": "BTCUSD_PERP",
            "pair": "BTCUSD",
            "status": "NEW",
            "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
            "price": "30005",
            "avgPrice": "0.0",
            "origQty": "1",
            "executedQty": "0",
            "cumQty": "0",
            "cumBase": "0",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "reduceOnly": False,
            "closePosition": False,
            "side": "BUY",
            "positionSide": "LONG",
            "stopPrice": "0",
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "origType": "LIMIT",
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
            "updateTime": 1629182711600,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.modify_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "PUT"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["side"] == ModifyOrderSideEnum["BUY"].value

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ModifyOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ModifyOrderResponse, "from_dict"):
            expected = ModifyOrderResponse.from_dict(expected_response)
        else:
            expected = ModifyOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_modify_order_success_with_optional_params(self, mock_get_signature):
        """Test modify_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "side": ModifyOrderSideEnum["BUY"].value,
            "order_id": 1,
            "orig_client_order_id": "1",
            "quantity": 1.0,
            "price": 1.0,
            "price_match": ModifyOrderPriceMatchEnum["NONE"].value,
            "recv_window": 5000,
        }

        expected_response = {
            "orderId": 20072994037,
            "symbol": "BTCUSD_PERP",
            "pair": "BTCUSD",
            "status": "NEW",
            "clientOrderId": "LJ9R4QZDihCaS8UAOOLpgW",
            "price": "30005",
            "avgPrice": "0.0",
            "origQty": "1",
            "executedQty": "0",
            "cumQty": "0",
            "cumBase": "0",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "reduceOnly": False,
            "closePosition": False,
            "side": "BUY",
            "positionSide": "LONG",
            "stopPrice": "0",
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "origType": "LIMIT",
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
            "updateTime": 1629182711600,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.modify_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "PUT"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ModifyOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ModifyOrderResponse, "from_dict"):
            expected = ModifyOrderResponse.from_dict(expected_response)
        else:
            expected = ModifyOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_modify_order_missing_required_param_symbol(self):
        """Test that modify_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": ModifyOrderSideEnum["BUY"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.modify_order(**params)

    def test_modify_order_missing_required_param_side(self):
        """Test that modify_order() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": ModifyOrderSideEnum["BUY"].value,
        }
        params["side"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.modify_order(**params)

    def test_modify_order_server_error(self):
        """Test that modify_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "side": ModifyOrderSideEnum["BUY"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.modify_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.modify_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_new_order_success(self, mock_get_signature):
        """Test new_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "side": NewOrderSideEnum["BUY"].value,
            "type": NewOrderTypeEnum["LIMIT"].value,
        }

        expected_response = {
            "clientOrderId": "testOrder",
            "cumQty": "0",
            "cumBase": "0",
            "executedQty": "0",
            "orderId": 22542179,
            "avgPrice": "0.0",
            "origQty": "10",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "timeInForce": "GTC",
            "type": "TRAILING_STOP_MARKET",
            "origType": "TRAILING_STOP_MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "updateTime": 1566818724722,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["side"] == NewOrderSideEnum["BUY"].value
        assert normalized["type"] == NewOrderTypeEnum["LIMIT"].value

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(NewOrderResponse, "from_dict"):
            expected = NewOrderResponse.from_dict(expected_response)
        else:
            expected = NewOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_new_order_success_with_optional_params(self, mock_get_signature):
        """Test new_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "side": NewOrderSideEnum["BUY"].value,
            "type": NewOrderTypeEnum["LIMIT"].value,
            "position_side": NewOrderPositionSideEnum["BOTH"].value,
            "time_in_force": NewOrderTimeInForceEnum["GTC"].value,
            "quantity": 1.0,
            "reduce_only": "False",
            "price": 1.0,
            "new_client_order_id": "1",
            "stop_price": 1.0,
            "close_position": "close_position_example",
            "activation_price": 1.0,
            "callback_rate": 1.0,
            "working_type": NewOrderWorkingTypeEnum["MARK_PRICE"].value,
            "price_protect": "False",
            "new_order_resp_type": NewOrderNewOrderRespTypeEnum["ACK"].value,
            "price_match": NewOrderPriceMatchEnum["NONE"].value,
            "self_trade_prevention_mode": NewOrderSelfTradePreventionModeEnum[
                "NONE"
            ].value,
            "recv_window": 5000,
        }

        expected_response = {
            "clientOrderId": "testOrder",
            "cumQty": "0",
            "cumBase": "0",
            "executedQty": "0",
            "orderId": 22542179,
            "avgPrice": "0.0",
            "origQty": "10",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "timeInForce": "GTC",
            "type": "TRAILING_STOP_MARKET",
            "origType": "TRAILING_STOP_MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "updateTime": 1566818724722,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.new_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "POST"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(NewOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(NewOrderResponse, "from_dict"):
            expected = NewOrderResponse.from_dict(expected_response)
        else:
            expected = NewOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_new_order_missing_required_param_symbol(self):
        """Test that new_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewOrderSideEnum["BUY"].value,
            "type": NewOrderTypeEnum["LIMIT"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.new_order(**params)

    def test_new_order_missing_required_param_side(self):
        """Test that new_order() raises RequiredError when 'side' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewOrderSideEnum["BUY"].value,
            "type": NewOrderTypeEnum["LIMIT"].value,
        }
        params["side"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'side'"):
            self.client.new_order(**params)

    def test_new_order_missing_required_param_type(self):
        """Test that new_order() raises RequiredError when 'type' is missing."""
        params = {
            "symbol": "symbol_example",
            "side": NewOrderSideEnum["BUY"].value,
            "type": NewOrderTypeEnum["LIMIT"].value,
        }
        params["type"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'type'"):
            self.client.new_order(**params)

    def test_new_order_server_error(self):
        """Test that new_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "side": NewOrderSideEnum["BUY"].value,
            "type": NewOrderTypeEnum["LIMIT"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.new_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.new_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_position_adl_quantile_estimation_success(self, mock_get_signature):
        """Test position_adl_quantile_estimation() successfully with required parameters only."""

        expected_response = [
            {
                "symbol": "BTCUSD_200925",
                "adlQuantile": {"LONG": 3, "SHORT": 3, "HEDGE": 0},
            },
            {
                "symbol": "BTCUSD_201225",
                "adlQuantile": {"LONG": 1, "SHORT": 2, "BOTH": 0},
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.position_adl_quantile_estimation()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/adlQuantile" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(PositionAdlQuantileEstimationResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(PositionAdlQuantileEstimationResponse, "from_dict")
        ):
            expected = PositionAdlQuantileEstimationResponse.from_dict(
                expected_response
            )
        else:
            expected = PositionAdlQuantileEstimationResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_position_adl_quantile_estimation_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test position_adl_quantile_estimation() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "recv_window": 5000}

        expected_response = [
            {
                "symbol": "BTCUSD_200925",
                "adlQuantile": {"LONG": 3, "SHORT": 3, "HEDGE": 0},
            },
            {
                "symbol": "BTCUSD_201225",
                "adlQuantile": {"LONG": 1, "SHORT": 2, "BOTH": 0},
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.position_adl_quantile_estimation(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/adlQuantile" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(PositionAdlQuantileEstimationResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(PositionAdlQuantileEstimationResponse, "from_dict")
        ):
            expected = PositionAdlQuantileEstimationResponse.from_dict(
                expected_response
            )
        else:
            expected = PositionAdlQuantileEstimationResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_position_adl_quantile_estimation_server_error(self):
        """Test that position_adl_quantile_estimation() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.position_adl_quantile_estimation = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.position_adl_quantile_estimation()

    @patch("binance_common.utils.get_signature")
    def test_position_information_success(self, mock_get_signature):
        """Test position_information() successfully with required parameters only."""

        expected_response = [
            {
                "symbol": "BTCUSD_201225",
                "positionAmt": "0",
                "entryPrice": "0.0",
                "breakEvenPrice": "0.0",
                "markPrice": "0.00000000",
                "unRealizedProfit": "0.00000000",
                "liquidationPrice": "0",
                "leverage": "125",
                "maxQty": "50",
                "marginType": "cross",
                "isolatedMargin": "0.00000000",
                "isAutoAddMargin": "False",
                "positionSide": "BOTH",
                "updateTime": 0,
            },
            {
                "symbol": "BTCUSD_201225",
                "positionAmt": "1",
                "entryPrice": "11707.70000003",
                "breakEvenPrice": "11707.80000005",
                "markPrice": "11788.66626667",
                "unRealizedProfit": "0.00005866",
                "liquidationPrice": "11667.63509587",
                "leverage": "125",
                "maxQty": "50",
                "marginType": "cross",
                "isolatedMargin": "0.00000000",
                "isAutoAddMargin": "False",
                "positionSide": "LONG",
                "updateTime": 1627026881327,
            },
            {
                "symbol": "BTCUSD_201225",
                "positionAmt": "0",
                "entryPrice": "0.0",
                "breakEvenPrice": "0.0",
                "markPrice": "0.00000000",
                "unRealizedProfit": "0.00000000",
                "liquidationPrice": "0",
                "leverage": "125",
                "maxQty": "50",
                "marginType": "cross",
                "isolatedMargin": "0.00000000",
                "isAutoAddMargin": "False",
                "positionSide": "SHORT",
                "updateTime": 1627026881327,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.position_information()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/positionRisk" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(PositionInformationResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(PositionInformationResponse, "from_dict"):
            expected = PositionInformationResponse.from_dict(expected_response)
        else:
            expected = PositionInformationResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_position_information_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test position_information() successfully with optional parameters."""

        params = {
            "margin_asset": "margin_asset_example",
            "pair": "pair_example",
            "recv_window": 5000,
        }

        expected_response = [
            {
                "symbol": "BTCUSD_201225",
                "positionAmt": "0",
                "entryPrice": "0.0",
                "breakEvenPrice": "0.0",
                "markPrice": "0.00000000",
                "unRealizedProfit": "0.00000000",
                "liquidationPrice": "0",
                "leverage": "125",
                "maxQty": "50",
                "marginType": "cross",
                "isolatedMargin": "0.00000000",
                "isAutoAddMargin": "False",
                "positionSide": "BOTH",
                "updateTime": 0,
            },
            {
                "symbol": "BTCUSD_201225",
                "positionAmt": "1",
                "entryPrice": "11707.70000003",
                "breakEvenPrice": "11707.80000005",
                "markPrice": "11788.66626667",
                "unRealizedProfit": "0.00005866",
                "liquidationPrice": "11667.63509587",
                "leverage": "125",
                "maxQty": "50",
                "marginType": "cross",
                "isolatedMargin": "0.00000000",
                "isAutoAddMargin": "False",
                "positionSide": "LONG",
                "updateTime": 1627026881327,
            },
            {
                "symbol": "BTCUSD_201225",
                "positionAmt": "0",
                "entryPrice": "0.0",
                "breakEvenPrice": "0.0",
                "markPrice": "0.00000000",
                "unRealizedProfit": "0.00000000",
                "liquidationPrice": "0",
                "leverage": "125",
                "maxQty": "50",
                "marginType": "cross",
                "isolatedMargin": "0.00000000",
                "isAutoAddMargin": "False",
                "positionSide": "SHORT",
                "updateTime": 1627026881327,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.position_information(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/positionRisk" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(PositionInformationResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(PositionInformationResponse, "from_dict"):
            expected = PositionInformationResponse.from_dict(expected_response)
        else:
            expected = PositionInformationResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_position_information_server_error(self):
        """Test that position_information() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.position_information = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.position_information()

    @patch("binance_common.utils.get_signature")
    def test_query_current_open_order_success(self, mock_get_signature):
        """Test query_current_open_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "avgPrice": "0.0",
            "clientOrderId": "abc",
            "cumBase": "0",
            "executedQty": "0",
            "orderId": 1917641,
            "origQty": "0.40",
            "origType": "TRAILING_STOP_MARKET",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "time": 1579276756075,
            "timeInForce": "GTC",
            "type": "TRAILING_STOP_MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "updateTime": 1579276756075,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_current_open_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/openOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCurrentOpenOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryCurrentOpenOrderResponse, "from_dict"):
            expected = QueryCurrentOpenOrderResponse.from_dict(expected_response)
        else:
            expected = QueryCurrentOpenOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_current_open_order_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test query_current_open_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "avgPrice": "0.0",
            "clientOrderId": "abc",
            "cumBase": "0",
            "executedQty": "0",
            "orderId": 1917641,
            "origQty": "0.40",
            "origType": "TRAILING_STOP_MARKET",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "time": 1579276756075,
            "timeInForce": "GTC",
            "type": "TRAILING_STOP_MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "updateTime": 1579276756075,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_current_open_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/openOrder" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryCurrentOpenOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryCurrentOpenOrderResponse, "from_dict"):
            expected = QueryCurrentOpenOrderResponse.from_dict(expected_response)
        else:
            expected = QueryCurrentOpenOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_current_open_order_missing_required_param_symbol(self):
        """Test that query_current_open_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_current_open_order(**params)

    def test_query_current_open_order_server_error(self):
        """Test that query_current_open_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_current_open_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_current_open_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_query_order_success(self, mock_get_signature):
        """Test query_order() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "avgPrice": "0.0",
            "clientOrderId": "abc",
            "cumBase": "0",
            "executedQty": "0",
            "orderId": 1917641,
            "origQty": "0.40",
            "origType": "TRAILING_STOP_MARKET",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "time": 1579276756075,
            "timeInForce": "GTC",
            "type": "TRAILING_STOP_MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "updateTime": 1579276756075,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryOrderResponse, "from_dict"):
            expected = QueryOrderResponse.from_dict(expected_response)
        else:
            expected = QueryOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_query_order_success_with_optional_params(self, mock_get_signature):
        """Test query_order() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "order_id": 1,
            "orig_client_order_id": "1",
            "recv_window": 5000,
        }

        expected_response = {
            "avgPrice": "0.0",
            "clientOrderId": "abc",
            "cumBase": "0",
            "executedQty": "0",
            "orderId": 1917641,
            "origQty": "0.40",
            "origType": "TRAILING_STOP_MARKET",
            "price": "0",
            "reduceOnly": False,
            "side": "BUY",
            "positionSide": "SHORT",
            "status": "NEW",
            "stopPrice": "9300",
            "closePosition": False,
            "symbol": "BTCUSD_200925",
            "pair": "BTCUSD",
            "time": 1579276756075,
            "timeInForce": "GTC",
            "type": "TRAILING_STOP_MARKET",
            "activatePrice": "9020",
            "priceRate": "0.3",
            "updateTime": 1579276756075,
            "workingType": "CONTRACT_PRICE",
            "priceProtect": False,
            "priceMatch": "NONE",
            "selfTradePreventionMode": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.query_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(QueryOrderResponse, "from_dict"):
            expected = QueryOrderResponse.from_dict(expected_response)
        else:
            expected = QueryOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_order_missing_required_param_symbol(self):
        """Test that query_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_order(**params)

    def test_query_order_server_error(self):
        """Test that query_order() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.query_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_users_force_orders_success(self, mock_get_signature):
        """Test users_force_orders() successfully with required parameters only."""

        expected_response = [
            {
                "orderId": 165123080,
                "symbol": "BTCUSD_200925",
                "pair": "BTCUSD",
                "status": "FILLED",
                "clientOrderId": "autoclose-1596542005017000006",
                "price": "11326.9",
                "avgPrice": "11326.9",
                "origQty": "1",
                "executedQty": "1",
                "cumBase": "0.00882854",
                "timeInForce": "IOC",
                "type": "LIMIT",
                "reduceOnly": False,
                "closePosition": False,
                "side": "SELL",
                "positionSide": "BOTH",
                "stopPrice": "0",
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "origType": "LIMIT",
                "time": 1596542005019,
                "updateTime": 1596542005050,
            },
            {
                "orderId": 207251986,
                "symbol": "BTCUSD_200925",
                "pair": "BTCUSD",
                "status": "FILLED",
                "clientOrderId": "autoclose-1597307316020000006",
                "price": "11619.4",
                "avgPrice": "11661.2",
                "origQty": "1",
                "executedQty": "1",
                "cumBase": "0.00857544",
                "timeInForce": "IOC",
                "type": "LIMIT",
                "reduceOnly": False,
                "closePosition": False,
                "side": "SELL",
                "positionSide": "LONG",
                "stopPrice": "0",
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "origType": "LIMIT",
                "time": 1597307316022,
                "updateTime": 1597307316035,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.users_force_orders()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/forceOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(UsersForceOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(UsersForceOrdersResponse, "from_dict"):
            expected = UsersForceOrdersResponse.from_dict(expected_response)
        else:
            expected = UsersForceOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_users_force_orders_success_with_optional_params(self, mock_get_signature):
        """Test users_force_orders() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "auto_close_type": UsersForceOrdersAutoCloseTypeEnum["LIQUIDATION"].value,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
            "recv_window": 5000,
        }

        expected_response = [
            {
                "orderId": 165123080,
                "symbol": "BTCUSD_200925",
                "pair": "BTCUSD",
                "status": "FILLED",
                "clientOrderId": "autoclose-1596542005017000006",
                "price": "11326.9",
                "avgPrice": "11326.9",
                "origQty": "1",
                "executedQty": "1",
                "cumBase": "0.00882854",
                "timeInForce": "IOC",
                "type": "LIMIT",
                "reduceOnly": False,
                "closePosition": False,
                "side": "SELL",
                "positionSide": "BOTH",
                "stopPrice": "0",
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "origType": "LIMIT",
                "time": 1596542005019,
                "updateTime": 1596542005050,
            },
            {
                "orderId": 207251986,
                "symbol": "BTCUSD_200925",
                "pair": "BTCUSD",
                "status": "FILLED",
                "clientOrderId": "autoclose-1597307316020000006",
                "price": "11619.4",
                "avgPrice": "11661.2",
                "origQty": "1",
                "executedQty": "1",
                "cumBase": "0.00857544",
                "timeInForce": "IOC",
                "type": "LIMIT",
                "reduceOnly": False,
                "closePosition": False,
                "side": "SELL",
                "positionSide": "LONG",
                "stopPrice": "0",
                "workingType": "CONTRACT_PRICE",
                "priceProtect": False,
                "origType": "LIMIT",
                "time": 1597307316022,
                "updateTime": 1597307316035,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.users_force_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/dapi/v1/forceOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(UsersForceOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(UsersForceOrdersResponse, "from_dict"):
            expected = UsersForceOrdersResponse.from_dict(expected_response)
        else:
            expected = UsersForceOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_users_force_orders_server_error(self):
        """Test that users_force_orders() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.users_force_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.users_force_orders()
