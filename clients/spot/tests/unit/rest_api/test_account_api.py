"""
Binance Spot REST API

OpenAPI Specifications for the Binance Spot REST API

API documents:
  - [Github rest-api documentation file](https://github.com/binance/binance-spot-api-docs/blob/master/rest-api.md)
  - [General API information for rest-api on website](https://developers.binance.com/docs/binance-spot-api-docs/rest-api/general-api-information)

The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import pytest
import requests

from unittest.mock import MagicMock, patch
from urllib.parse import parse_qs

from binance_common.configuration import ConfigurationRestAPI
from binance_common.errors import RequiredError
from binance_common.utils import normalize_query_values, is_one_of_model, snake_to_camel

from binance_sdk_spot.rest_api.api import AccountApi
from binance_sdk_spot.rest_api.models import AccountCommissionResponse
from binance_sdk_spot.rest_api.models import AllOrderListResponse
from binance_sdk_spot.rest_api.models import AllOrdersResponse
from binance_sdk_spot.rest_api.models import GetAccountResponse
from binance_sdk_spot.rest_api.models import GetOpenOrdersResponse
from binance_sdk_spot.rest_api.models import GetOrderResponse
from binance_sdk_spot.rest_api.models import GetOrderListResponse
from binance_sdk_spot.rest_api.models import MyAllocationsResponse
from binance_sdk_spot.rest_api.models import MyFiltersResponse
from binance_sdk_spot.rest_api.models import MyPreventedMatchesResponse
from binance_sdk_spot.rest_api.models import MyTradesResponse
from binance_sdk_spot.rest_api.models import OpenOrderListResponse
from binance_sdk_spot.rest_api.models import OrderAmendmentsResponse
from binance_sdk_spot.rest_api.models import RateLimitOrderResponse


class TestAccountApi:
    @pytest.fixture(autouse=True)
    def setup_client(self):
        """Setup a client instance with mocked session before each test method."""
        self.mock_session = MagicMock(spec=requests.Session)
        config = ConfigurationRestAPI(
            api_key="test-api-key",
            api_secret="test-api-secret",
        )
        self.client = AccountApi(configuration=config, session=self.mock_session)

    def set_mock_response(self, data: dict = {}, status_code=200, headers=None):
        """Helper method to setup mock response for the client's session request."""
        if headers is None:
            headers = {}

        mock_response = MagicMock()
        mock_response.status_code = status_code
        mock_response.json.return_value = data
        mock_response.text = json.dumps(data)
        mock_response.headers = headers

        self.mock_session.request.return_value = mock_response

    @patch("binance_common.utils.get_signature")
    def test_account_commission_success(self, mock_get_signature):
        """Test account_commission() successfully with required parameters only."""

        params = {"symbol": "BNBUSDT"}

        expected_response = {
            "symbol": "BTCUSDT",
            "standardCommission": {
                "maker": "0.00000010",
                "taker": "0.00000020",
                "buyer": "0.00000030",
                "seller": "0.00000040",
            },
            "specialCommission": {
                "maker": "0.01000000",
                "taker": "0.02000000",
                "buyer": "0.03000000",
                "seller": "0.04000000",
            },
            "taxCommission": {
                "maker": "0.00000112",
                "taker": "0.00000114",
                "buyer": "0.00000118",
                "seller": "0.00000116",
            },
            "discount": {
                "enabledForAccount": True,
                "enabledForSymbol": True,
                "discountAsset": "BNB",
                "discount": "0.75000000",
            },
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.account_commission(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/account/commission" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "BNBUSDT"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(AccountCommissionResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(AccountCommissionResponse, "from_dict"):
            expected = AccountCommissionResponse.from_dict(expected_response)
        else:
            expected = AccountCommissionResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_account_commission_success_with_optional_params(self, mock_get_signature):
        """Test account_commission() successfully with optional parameters."""

        params = {"symbol": "BNBUSDT"}

        expected_response = {
            "symbol": "BTCUSDT",
            "standardCommission": {
                "maker": "0.00000010",
                "taker": "0.00000020",
                "buyer": "0.00000030",
                "seller": "0.00000040",
            },
            "specialCommission": {
                "maker": "0.01000000",
                "taker": "0.02000000",
                "buyer": "0.03000000",
                "seller": "0.04000000",
            },
            "taxCommission": {
                "maker": "0.00000112",
                "taker": "0.00000114",
                "buyer": "0.00000118",
                "seller": "0.00000116",
            },
            "discount": {
                "enabledForAccount": True,
                "enabledForSymbol": True,
                "discountAsset": "BNB",
                "discount": "0.75000000",
            },
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.account_commission(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/account/commission" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(AccountCommissionResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(AccountCommissionResponse, "from_dict"):
            expected = AccountCommissionResponse.from_dict(expected_response)
        else:
            expected = AccountCommissionResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_account_commission_missing_required_param_symbol(self):
        """Test that account_commission() raises RequiredError when 'symbol' is missing."""
        params = {"symbol": "BNBUSDT"}
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.account_commission(**params)

    def test_account_commission_server_error(self):
        """Test that account_commission() raises an error when the server returns an error."""

        params = {"symbol": "BNBUSDT"}

        mock_error = Exception("ResponseError")
        self.client.account_commission = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.account_commission(**params)

    @patch("binance_common.utils.get_signature")
    def test_all_order_list_success(self, mock_get_signature):
        """Test all_order_list() successfully with required parameters only."""

        expected_response = [
            {
                "orderListId": 29,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "amEEAXryFzFwYF1FeRpUoZ",
                "transactionTime": 1565245913483,
                "symbol": "LTCBTC",
                "orders": [
                    {
                        "symbol": "LTCBTC",
                        "orderId": 5,
                        "clientOrderId": "Jr1h6xirOxgeJOUuYQS7V3",
                    },
                    {
                        "symbol": "LTCBTC",
                        "orderId": 4,
                        "clientOrderId": "oD7aesZqjEGlZrbtRpy5zB",
                    },
                ],
            },
            {
                "orderListId": 28,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "hG7hFNxJV6cZy3Ze4AUT4d",
                "transactionTime": 1565245913407,
                "symbol": "LTCBTC",
                "orders": [
                    {
                        "symbol": "LTCBTC",
                        "orderId": 2,
                        "clientOrderId": "j6lFOfbmFMRjTYA7rRJ0LP",
                    },
                    {
                        "symbol": "LTCBTC",
                        "orderId": 3,
                        "clientOrderId": "z0KCjOdditiLS5ekAFtK81",
                    },
                ],
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.all_order_list()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/allOrderList" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(AllOrderListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(AllOrderListResponse, "from_dict"):
            expected = AllOrderListResponse.from_dict(expected_response)
        else:
            expected = AllOrderListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_all_order_list_success_with_optional_params(self, mock_get_signature):
        """Test all_order_list() successfully with optional parameters."""

        params = {
            "from_id": 1,
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "limit": 500,
            "recv_window": 5000.0,
        }

        expected_response = [
            {
                "orderListId": 29,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "amEEAXryFzFwYF1FeRpUoZ",
                "transactionTime": 1565245913483,
                "symbol": "LTCBTC",
                "orders": [
                    {
                        "symbol": "LTCBTC",
                        "orderId": 5,
                        "clientOrderId": "Jr1h6xirOxgeJOUuYQS7V3",
                    },
                    {
                        "symbol": "LTCBTC",
                        "orderId": 4,
                        "clientOrderId": "oD7aesZqjEGlZrbtRpy5zB",
                    },
                ],
            },
            {
                "orderListId": 28,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "hG7hFNxJV6cZy3Ze4AUT4d",
                "transactionTime": 1565245913407,
                "symbol": "LTCBTC",
                "orders": [
                    {
                        "symbol": "LTCBTC",
                        "orderId": 2,
                        "clientOrderId": "j6lFOfbmFMRjTYA7rRJ0LP",
                    },
                    {
                        "symbol": "LTCBTC",
                        "orderId": 3,
                        "clientOrderId": "z0KCjOdditiLS5ekAFtK81",
                    },
                ],
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.all_order_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/allOrderList" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(AllOrderListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(AllOrderListResponse, "from_dict"):
            expected = AllOrderListResponse.from_dict(expected_response)
        else:
            expected = AllOrderListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_all_order_list_server_error(self):
        """Test that all_order_list() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.all_order_list = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.all_order_list()

    @patch("binance_common.utils.get_signature")
    def test_all_orders_success(self, mock_get_signature):
        """Test all_orders() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = [
            {
                "symbol": "LTCBTC",
                "orderId": 1,
                "orderListId": -1,
                "clientOrderId": "myOrder1",
                "price": "0.1",
                "origQty": "1.0",
                "executedQty": "0.0",
                "cummulativeQuoteQty": "0.0",
                "status": "NEW",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "BUY",
                "stopPrice": "0.0",
                "icebergQty": "0.0",
                "time": 1499827319559,
                "updateTime": 1499827319559,
                "isWorking": True,
                "origQuoteOrderQty": "0.000000",
                "workingTime": 1499827319559,
                "selfTradePreventionMode": "NONE",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.all_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/allOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "BNBUSDT"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(AllOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(AllOrdersResponse, "from_dict"):
            expected = AllOrdersResponse.from_dict(expected_response)
        else:
            expected = AllOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_all_orders_success_with_optional_params(self, mock_get_signature):
        """Test all_orders() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "order_id": 1,
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "limit": 500,
            "recv_window": 5000.0,
        }

        expected_response = [
            {
                "symbol": "LTCBTC",
                "orderId": 1,
                "orderListId": -1,
                "clientOrderId": "myOrder1",
                "price": "0.1",
                "origQty": "1.0",
                "executedQty": "0.0",
                "cummulativeQuoteQty": "0.0",
                "status": "NEW",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "BUY",
                "stopPrice": "0.0",
                "icebergQty": "0.0",
                "time": 1499827319559,
                "updateTime": 1499827319559,
                "isWorking": True,
                "origQuoteOrderQty": "0.000000",
                "workingTime": 1499827319559,
                "selfTradePreventionMode": "NONE",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.all_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/allOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(AllOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(AllOrdersResponse, "from_dict"):
            expected = AllOrdersResponse.from_dict(expected_response)
        else:
            expected = AllOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_all_orders_missing_required_param_symbol(self):
        """Test that all_orders() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.all_orders(**params)

    def test_all_orders_server_error(self):
        """Test that all_orders() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.client.all_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.all_orders(**params)

    @patch("binance_common.utils.get_signature")
    def test_get_account_success(self, mock_get_signature):
        """Test get_account() successfully with required parameters only."""

        expected_response = {
            "makerCommission": 15,
            "takerCommission": 15,
            "buyerCommission": 0,
            "sellerCommission": 0,
            "commissionRates": {
                "maker": "0.00150000",
                "taker": "0.00150000",
                "buyer": "0.00000000",
                "seller": "0.00000000",
            },
            "canTrade": True,
            "canWithdraw": True,
            "canDeposit": True,
            "brokered": False,
            "requireSelfTradePrevention": False,
            "preventSor": False,
            "updateTime": 123456789,
            "accountType": "SPOT",
            "balances": [
                {"asset": "LTC", "free": "4763368.68006011", "locked": "0.00000000"},
                {"asset": "BTC", "free": "4723846.89208129", "locked": "0.00000000"},
            ],
            "permissions": ["SPOT"],
            "uid": 354937868,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_account()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/account" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(GetAccountResponse, "from_dict"):
            expected = GetAccountResponse.from_dict(expected_response)
        else:
            expected = GetAccountResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_account_success_with_optional_params(self, mock_get_signature):
        """Test get_account() successfully with optional parameters."""

        params = {"omit_zero_balances": False, "recv_window": 5000.0}

        expected_response = {
            "makerCommission": 15,
            "takerCommission": 15,
            "buyerCommission": 0,
            "sellerCommission": 0,
            "commissionRates": {
                "maker": "0.00150000",
                "taker": "0.00150000",
                "buyer": "0.00000000",
                "seller": "0.00000000",
            },
            "canTrade": True,
            "canWithdraw": True,
            "canDeposit": True,
            "brokered": False,
            "requireSelfTradePrevention": False,
            "preventSor": False,
            "updateTime": 123456789,
            "accountType": "SPOT",
            "balances": [
                {"asset": "LTC", "free": "4763368.68006011", "locked": "0.00000000"},
                {"asset": "BTC", "free": "4723846.89208129", "locked": "0.00000000"},
            ],
            "permissions": ["SPOT"],
            "uid": 354937868,
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_account(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/account" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetAccountResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(GetAccountResponse, "from_dict"):
            expected = GetAccountResponse.from_dict(expected_response)
        else:
            expected = GetAccountResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_account_server_error(self):
        """Test that get_account() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.get_account = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_account()

    @patch("binance_common.utils.get_signature")
    def test_get_open_orders_success(self, mock_get_signature):
        """Test get_open_orders() successfully with required parameters only."""

        expected_response = [
            {
                "symbol": "LTCBTC",
                "orderId": 1,
                "orderListId": -1,
                "clientOrderId": "myOrder1",
                "price": "0.1",
                "origQty": "1.0",
                "executedQty": "0.0",
                "cummulativeQuoteQty": "0.0",
                "status": "NEW",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "BUY",
                "stopPrice": "0.0",
                "icebergQty": "0.0",
                "time": 1499827319559,
                "updateTime": 1499827319559,
                "isWorking": True,
                "origQuoteOrderQty": "0.000000",
                "workingTime": 1499827319559,
                "selfTradePreventionMode": "NONE",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_open_orders()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(GetOpenOrdersResponse, "from_dict"):
            expected = GetOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = GetOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_open_orders_success_with_optional_params(self, mock_get_signature):
        """Test get_open_orders() successfully with optional parameters."""

        params = {"symbol": "BNBUSDT", "recv_window": 5000.0}

        expected_response = [
            {
                "symbol": "LTCBTC",
                "orderId": 1,
                "orderListId": -1,
                "clientOrderId": "myOrder1",
                "price": "0.1",
                "origQty": "1.0",
                "executedQty": "0.0",
                "cummulativeQuoteQty": "0.0",
                "status": "NEW",
                "timeInForce": "GTC",
                "type": "LIMIT",
                "side": "BUY",
                "stopPrice": "0.0",
                "icebergQty": "0.0",
                "time": 1499827319559,
                "updateTime": 1499827319559,
                "isWorking": True,
                "origQuoteOrderQty": "0.000000",
                "workingTime": 1499827319559,
                "selfTradePreventionMode": "NONE",
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_open_orders(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/openOrders" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetOpenOrdersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(GetOpenOrdersResponse, "from_dict"):
            expected = GetOpenOrdersResponse.from_dict(expected_response)
        else:
            expected = GetOpenOrdersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_open_orders_server_error(self):
        """Test that get_open_orders() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.get_open_orders = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_open_orders()

    @patch("binance_common.utils.get_signature")
    def test_get_order_success(self, mock_get_signature):
        """Test get_order() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "symbol": "LTCBTC",
            "orderId": 1,
            "orderListId": -1,
            "clientOrderId": "myOrder1",
            "price": "0.1",
            "origQty": "1.0",
            "executedQty": "0.0",
            "cummulativeQuoteQty": "0.0",
            "status": "NEW",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "side": "BUY",
            "stopPrice": "0.0",
            "icebergQty": "0.0",
            "time": 1499827319559,
            "updateTime": 1499827319559,
            "isWorking": True,
            "workingTime": 1499827319559,
            "origQuoteOrderQty": "0.000000",
            "selfTradePreventionMode": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "BNBUSDT"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(GetOrderResponse, "from_dict"):
            expected = GetOrderResponse.from_dict(expected_response)
        else:
            expected = GetOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_order_success_with_optional_params(self, mock_get_signature):
        """Test get_order() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "order_id": 1,
            "orig_client_order_id": "orig_client_order_id_example",
            "recv_window": 5000.0,
        }

        expected_response = {
            "symbol": "LTCBTC",
            "orderId": 1,
            "orderListId": -1,
            "clientOrderId": "myOrder1",
            "price": "0.1",
            "origQty": "1.0",
            "executedQty": "0.0",
            "cummulativeQuoteQty": "0.0",
            "status": "NEW",
            "timeInForce": "GTC",
            "type": "LIMIT",
            "side": "BUY",
            "stopPrice": "0.0",
            "icebergQty": "0.0",
            "time": 1499827319559,
            "updateTime": 1499827319559,
            "isWorking": True,
            "workingTime": 1499827319559,
            "origQuoteOrderQty": "0.000000",
            "selfTradePreventionMode": "NONE",
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(GetOrderResponse, "from_dict"):
            expected = GetOrderResponse.from_dict(expected_response)
        else:
            expected = GetOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_order_missing_required_param_symbol(self):
        """Test that get_order() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.get_order(**params)

    def test_get_order_server_error(self):
        """Test that get_order() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.client.get_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_order(**params)

    @patch("binance_common.utils.get_signature")
    def test_get_order_list_success(self, mock_get_signature):
        """Test get_order_list() successfully with required parameters only."""

        expected_response = {
            "orderListId": 27,
            "contingencyType": "OCO",
            "listStatusType": "EXEC_STARTED",
            "listOrderStatus": "EXECUTING",
            "listClientOrderId": "h2USkA5YQpaXHPIrkd96xE",
            "transactionTime": 1565245656253,
            "symbol": "LTCBTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 5,
                    "clientOrderId": "ARzZ9I00CPM8i3NhmU9Ega",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 4,
                    "clientOrderId": "qD1gy3kc3Gx0rihm9Y3xwS",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_order_list()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/orderList" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetOrderListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(GetOrderListResponse, "from_dict"):
            expected = GetOrderListResponse.from_dict(expected_response)
        else:
            expected = GetOrderListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_get_order_list_success_with_optional_params(self, mock_get_signature):
        """Test get_order_list() successfully with optional parameters."""

        params = {
            "order_list_id": 1,
            "orig_client_order_id": "orig_client_order_id_example",
            "recv_window": 5000.0,
        }

        expected_response = {
            "orderListId": 27,
            "contingencyType": "OCO",
            "listStatusType": "EXEC_STARTED",
            "listOrderStatus": "EXECUTING",
            "listClientOrderId": "h2USkA5YQpaXHPIrkd96xE",
            "transactionTime": 1565245656253,
            "symbol": "LTCBTC",
            "orders": [
                {
                    "symbol": "LTCBTC",
                    "orderId": 5,
                    "clientOrderId": "ARzZ9I00CPM8i3NhmU9Ega",
                },
                {
                    "symbol": "LTCBTC",
                    "orderId": 4,
                    "clientOrderId": "qD1gy3kc3Gx0rihm9Y3xwS",
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.get_order_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/orderList" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetOrderListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(GetOrderListResponse, "from_dict"):
            expected = GetOrderListResponse.from_dict(expected_response)
        else:
            expected = GetOrderListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_order_list_server_error(self):
        """Test that get_order_list() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.get_order_list = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_order_list()

    @patch("binance_common.utils.get_signature")
    def test_my_allocations_success(self, mock_get_signature):
        """Test my_allocations() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "allocationId": 0,
                "allocationType": "SOR",
                "orderId": 1,
                "orderListId": -1,
                "price": "1.00000000",
                "qty": "5.00000000",
                "quoteQty": "5.00000000",
                "commission": "0.00000000",
                "commissionAsset": "BTC",
                "time": 1687506878118,
                "isBuyer": True,
                "isMaker": False,
                "isAllocator": False,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.my_allocations(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/myAllocations" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "BNBUSDT"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MyAllocationsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(MyAllocationsResponse, "from_dict"):
            expected = MyAllocationsResponse.from_dict(expected_response)
        else:
            expected = MyAllocationsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_my_allocations_success_with_optional_params(self, mock_get_signature):
        """Test my_allocations() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "from_allocation_id": 1,
            "limit": 500,
            "order_id": 1,
            "recv_window": 5000.0,
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "allocationId": 0,
                "allocationType": "SOR",
                "orderId": 1,
                "orderListId": -1,
                "price": "1.00000000",
                "qty": "5.00000000",
                "quoteQty": "5.00000000",
                "commission": "0.00000000",
                "commissionAsset": "BTC",
                "time": 1687506878118,
                "isBuyer": True,
                "isMaker": False,
                "isAllocator": False,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.my_allocations(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/myAllocations" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MyAllocationsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(MyAllocationsResponse, "from_dict"):
            expected = MyAllocationsResponse.from_dict(expected_response)
        else:
            expected = MyAllocationsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_my_allocations_missing_required_param_symbol(self):
        """Test that my_allocations() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.my_allocations(**params)

    def test_my_allocations_server_error(self):
        """Test that my_allocations() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.client.my_allocations = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.my_allocations(**params)

    @patch("binance_common.utils.get_signature")
    def test_my_filters_success(self, mock_get_signature):
        """Test my_filters() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = {
            "exchangeFilters": [
                {"filterType": "EXCHANGE_MAX_NUM_ORDERS", "maxNumOrders": 1000}
            ],
            "symbolFilters": [
                {"filterType": "MAX_NUM_ORDER_LISTS", "maxNumOrderLists": 20}
            ],
            "assetFilters": [
                {"filterType": "MAX_ASSET", "asset": "JPY", "limit": "1000000.00000000"}
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                },
                {
                    "rateLimitType": "ORDERS",
                    "interval": "DAY",
                    "intervalNum": 1,
                    "limit": 160000,
                },
                {
                    "rateLimitType": "RAW_REQUESTS",
                    "interval": "MINUTE",
                    "intervalNum": 5,
                    "limit": 61000,
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.my_filters(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/myFilters" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "BNBUSDT"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MyFiltersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(MyFiltersResponse, "from_dict"):
            expected = MyFiltersResponse.from_dict(expected_response)
        else:
            expected = MyFiltersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_my_filters_success_with_optional_params(self, mock_get_signature):
        """Test my_filters() successfully with optional parameters."""

        params = {"symbol": "BNBUSDT", "recv_window": 5000.0}

        expected_response = {
            "exchangeFilters": [
                {"filterType": "EXCHANGE_MAX_NUM_ORDERS", "maxNumOrders": 1000}
            ],
            "symbolFilters": [
                {"filterType": "MAX_NUM_ORDER_LISTS", "maxNumOrderLists": 20}
            ],
            "assetFilters": [
                {"filterType": "MAX_ASSET", "asset": "JPY", "limit": "1000000.00000000"}
            ],
            "rateLimits": [
                {
                    "rateLimitType": "REQUEST_WEIGHT",
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 6000,
                },
                {
                    "rateLimitType": "ORDERS",
                    "interval": "DAY",
                    "intervalNum": 1,
                    "limit": 160000,
                },
                {
                    "rateLimitType": "RAW_REQUESTS",
                    "interval": "MINUTE",
                    "intervalNum": 5,
                    "limit": 61000,
                },
            ],
        }
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.my_filters(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/myFilters" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MyFiltersResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(MyFiltersResponse, "from_dict"):
            expected = MyFiltersResponse.from_dict(expected_response)
        else:
            expected = MyFiltersResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_my_filters_missing_required_param_symbol(self):
        """Test that my_filters() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.my_filters(**params)

    def test_my_filters_server_error(self):
        """Test that my_filters() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.client.my_filters = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.my_filters(**params)

    @patch("binance_common.utils.get_signature")
    def test_my_prevented_matches_success(self, mock_get_signature):
        """Test my_prevented_matches() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "preventedMatchId": 1,
                "takerOrderId": 5,
                "makerSymbol": "BTCUSDT",
                "makerOrderId": 3,
                "tradeGroupId": 1,
                "selfTradePreventionMode": "EXPIRE_MAKER",
                "price": "1.100000",
                "makerPreventedQuantity": "1.300000",
                "transactTime": 1669101687094,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.my_prevented_matches(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/myPreventedMatches" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "BNBUSDT"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MyPreventedMatchesResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(MyPreventedMatchesResponse, "from_dict"):
            expected = MyPreventedMatchesResponse.from_dict(expected_response)
        else:
            expected = MyPreventedMatchesResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_my_prevented_matches_success_with_optional_params(
        self, mock_get_signature
    ):
        """Test my_prevented_matches() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "prevented_match_id": 1,
            "order_id": 1,
            "from_prevented_match_id": 1,
            "limit": 500,
            "recv_window": 5000.0,
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "preventedMatchId": 1,
                "takerOrderId": 5,
                "makerSymbol": "BTCUSDT",
                "makerOrderId": 3,
                "tradeGroupId": 1,
                "selfTradePreventionMode": "EXPIRE_MAKER",
                "price": "1.100000",
                "makerPreventedQuantity": "1.300000",
                "transactTime": 1669101687094,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.my_prevented_matches(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/myPreventedMatches" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MyPreventedMatchesResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(MyPreventedMatchesResponse, "from_dict"):
            expected = MyPreventedMatchesResponse.from_dict(expected_response)
        else:
            expected = MyPreventedMatchesResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_my_prevented_matches_missing_required_param_symbol(self):
        """Test that my_prevented_matches() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.my_prevented_matches(**params)

    def test_my_prevented_matches_server_error(self):
        """Test that my_prevented_matches() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.client.my_prevented_matches = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.my_prevented_matches(**params)

    @patch("binance_common.utils.get_signature")
    def test_my_trades_success(self, mock_get_signature):
        """Test my_trades() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
        }

        expected_response = [
            {
                "symbol": "BNBBTC",
                "id": 28457,
                "orderId": 100234,
                "orderListId": -1,
                "price": "4.00000100",
                "qty": "12.00000000",
                "quoteQty": "48.000012",
                "commission": "10.10000000",
                "commissionAsset": "BNB",
                "time": 1499865549590,
                "isBuyer": True,
                "isMaker": False,
                "isBestMatch": True,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.my_trades(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/myTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "BNBUSDT"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MyTradesResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(MyTradesResponse, "from_dict"):
            expected = MyTradesResponse.from_dict(expected_response)
        else:
            expected = MyTradesResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_my_trades_success_with_optional_params(self, mock_get_signature):
        """Test my_trades() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "order_id": 1,
            "start_time": 1735693200000,
            "end_time": 1735693200000,
            "from_id": 1,
            "limit": 500,
            "recv_window": 5000.0,
        }

        expected_response = [
            {
                "symbol": "BNBBTC",
                "id": 28457,
                "orderId": 100234,
                "orderListId": -1,
                "price": "4.00000100",
                "qty": "12.00000000",
                "quoteQty": "48.000012",
                "commission": "10.10000000",
                "commissionAsset": "BNB",
                "time": 1499865549590,
                "isBuyer": True,
                "isMaker": False,
                "isBestMatch": True,
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.my_trades(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/myTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MyTradesResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(MyTradesResponse, "from_dict"):
            expected = MyTradesResponse.from_dict(expected_response)
        else:
            expected = MyTradesResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_my_trades_missing_required_param_symbol(self):
        """Test that my_trades() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.my_trades(**params)

    def test_my_trades_server_error(self):
        """Test that my_trades() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
        }

        mock_error = Exception("ResponseError")
        self.client.my_trades = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.my_trades(**params)

    @patch("binance_common.utils.get_signature")
    def test_open_order_list_success(self, mock_get_signature):
        """Test open_order_list() successfully with required parameters only."""

        expected_response = [
            {
                "orderListId": 31,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "wuB13fmulKj3YjdqWEcsnp",
                "transactionTime": 1565246080644,
                "symbol": "LTCBTC",
                "orders": [
                    {
                        "symbol": "LTCBTC",
                        "orderId": 5,
                        "clientOrderId": "Cv1SnyPD3qhqpbjpYEHbd2",
                    },
                    {
                        "symbol": "LTCBTC",
                        "orderId": 4,
                        "clientOrderId": "r3EH2N76dHfLoSZWIUw1bT",
                    },
                ],
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.open_order_list()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/openOrderList" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OpenOrderListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(OpenOrderListResponse, "from_dict"):
            expected = OpenOrderListResponse.from_dict(expected_response)
        else:
            expected = OpenOrderListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_open_order_list_success_with_optional_params(self, mock_get_signature):
        """Test open_order_list() successfully with optional parameters."""

        params = {"recv_window": 5000.0}

        expected_response = [
            {
                "orderListId": 31,
                "contingencyType": "OCO",
                "listStatusType": "EXEC_STARTED",
                "listOrderStatus": "EXECUTING",
                "listClientOrderId": "wuB13fmulKj3YjdqWEcsnp",
                "transactionTime": 1565246080644,
                "symbol": "LTCBTC",
                "orders": [
                    {
                        "symbol": "LTCBTC",
                        "orderId": 5,
                        "clientOrderId": "Cv1SnyPD3qhqpbjpYEHbd2",
                    },
                    {
                        "symbol": "LTCBTC",
                        "orderId": 4,
                        "clientOrderId": "r3EH2N76dHfLoSZWIUw1bT",
                    },
                ],
            }
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.open_order_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/openOrderList" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OpenOrderListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(OpenOrderListResponse, "from_dict"):
            expected = OpenOrderListResponse.from_dict(expected_response)
        else:
            expected = OpenOrderListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_open_order_list_server_error(self):
        """Test that open_order_list() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.open_order_list = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.open_order_list()

    @patch("binance_common.utils.get_signature")
    def test_order_amendments_success(self, mock_get_signature):
        """Test order_amendments() successfully with required parameters only."""

        params = {
            "symbol": "BNBUSDT",
            "order_id": 1,
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "orderId": 9,
                "executionId": 22,
                "origClientOrderId": "W0fJ9fiLKHOJutovPK3oJp",
                "newClientOrderId": "UQ1Np3bmQ71jJzsSDW9Vpi",
                "origQty": "5.00000000",
                "newQty": "4.00000000",
                "time": 1741669661670,
            },
            {
                "symbol": "BTCUDST",
                "orderId": 9,
                "executionId": 25,
                "origClientOrderId": "UQ1Np3bmQ71jJzsSDW9Vpi",
                "newClientOrderId": "5uS0r35ohuQyDlCzZuYXq2",
                "origQty": "4.00000000",
                "newQty": "3.00000000",
                "time": 1741672924895,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.order_amendments(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/order/amendments" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "BNBUSDT"
        assert normalized["orderId"] == 1

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderAmendmentsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(OrderAmendmentsResponse, "from_dict"):
            expected = OrderAmendmentsResponse.from_dict(expected_response)
        else:
            expected = OrderAmendmentsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_order_amendments_success_with_optional_params(self, mock_get_signature):
        """Test order_amendments() successfully with optional parameters."""

        params = {
            "symbol": "BNBUSDT",
            "order_id": 1,
            "from_execution_id": 1,
            "limit": 500,
            "recv_window": 5000.0,
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "orderId": 9,
                "executionId": 22,
                "origClientOrderId": "W0fJ9fiLKHOJutovPK3oJp",
                "newClientOrderId": "UQ1Np3bmQ71jJzsSDW9Vpi",
                "origQty": "5.00000000",
                "newQty": "4.00000000",
                "time": 1741669661670,
            },
            {
                "symbol": "BTCUDST",
                "orderId": 9,
                "executionId": 25,
                "origClientOrderId": "UQ1Np3bmQ71jJzsSDW9Vpi",
                "newClientOrderId": "5uS0r35ohuQyDlCzZuYXq2",
                "origQty": "4.00000000",
                "newQty": "3.00000000",
                "time": 1741672924895,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.order_amendments(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/order/amendments" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderAmendmentsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(OrderAmendmentsResponse, "from_dict"):
            expected = OrderAmendmentsResponse.from_dict(expected_response)
        else:
            expected = OrderAmendmentsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_order_amendments_missing_required_param_symbol(self):
        """Test that order_amendments() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "order_id": 1,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.order_amendments(**params)

    def test_order_amendments_missing_required_param_order_id(self):
        """Test that order_amendments() raises RequiredError when 'order_id' is missing."""
        params = {
            "symbol": "BNBUSDT",
            "order_id": 1,
        }
        params["order_id"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'order_id'"
        ):
            self.client.order_amendments(**params)

    def test_order_amendments_server_error(self):
        """Test that order_amendments() raises an error when the server returns an error."""

        params = {
            "symbol": "BNBUSDT",
            "order_id": 1,
        }

        mock_error = Exception("ResponseError")
        self.client.order_amendments = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.order_amendments(**params)

    @patch("binance_common.utils.get_signature")
    def test_rate_limit_order_success(self, mock_get_signature):
        """Test rate_limit_order() successfully with required parameters only."""

        expected_response = [
            {
                "rateLimitType": "ORDERS",
                "interval": "SECOND",
                "intervalNum": 10,
                "limit": 50,
                "count": 0,
            },
            {
                "rateLimitType": "ORDERS",
                "interval": "DAY",
                "intervalNum": 1,
                "limit": 160000,
                "count": 0,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.rate_limit_order()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()
        mock_get_signature.assert_called_once()

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/rateLimit/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(RateLimitOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(RateLimitOrderResponse, "from_dict"):
            expected = RateLimitOrderResponse.from_dict(expected_response)
        else:
            expected = RateLimitOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    @patch("binance_common.utils.get_signature")
    def test_rate_limit_order_success_with_optional_params(self, mock_get_signature):
        """Test rate_limit_order() successfully with optional parameters."""

        params = {"recv_window": 5000.0}

        expected_response = [
            {
                "rateLimitType": "ORDERS",
                "interval": "SECOND",
                "intervalNum": 10,
                "limit": 50,
                "count": 0,
            },
            {
                "rateLimitType": "ORDERS",
                "interval": "DAY",
                "intervalNum": 1,
                "limit": 160000,
                "count": 0,
            },
        ]
        mock_get_signature.return_value = "mocked_signature"
        self.set_mock_response(expected_response)

        response = self.client.rate_limit_order(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "signature" in parse_qs(request_kwargs["params"])
        assert "/api/v3/rateLimit/order" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(RateLimitOrderResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(RateLimitOrderResponse, "from_dict"):
            expected = RateLimitOrderResponse.from_dict(expected_response)
        else:
            expected = RateLimitOrderResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_rate_limit_order_server_error(self):
        """Test that rate_limit_order() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.rate_limit_order = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.rate_limit_order()
