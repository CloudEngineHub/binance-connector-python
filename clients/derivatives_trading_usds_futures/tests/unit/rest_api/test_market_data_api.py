"""
Binance Derivatives Trading USDS Futures REST API

OpenAPI Specification for the Binance Derivatives Trading USDS Futures REST API
The version of the OpenAPI document: 1.0.0
Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import pytest
import requests

from unittest.mock import MagicMock
from urllib.parse import parse_qs

from binance_common.configuration import ConfigurationRestAPI
from binance_common.errors import RequiredError
from binance_common.utils import normalize_query_values, is_one_of_model, snake_to_camel

from binance_sdk_derivatives_trading_usds_futures.rest_api.api import MarketDataApi
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import BasisResponse
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    CheckServerTimeResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    CompositeIndexSymbolInformationResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    CompressedAggregateTradesListResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    ContinuousContractKlineCandlestickDataResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    ExchangeInformationResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    GetFundingRateHistoryResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    GetFundingRateInfoResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    IndexPriceKlineCandlestickDataResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    KlineCandlestickDataResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    LongShortRatioResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    MarkPriceResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    MarkPriceKlineCandlestickDataResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    MultiAssetsModeAssetIndexResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    OldTradesLookupResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    OpenInterestResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    OpenInterestStatisticsResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    OrderBookResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    PremiumIndexKlineDataResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    QuarterlyContractSettlementPriceResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    QueryIndexPriceConstituentsResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    QueryInsuranceFundBalanceSnapshotResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    RecentTradesListResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    SymbolOrderBookTickerResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    SymbolPriceTickerResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    SymbolPriceTickerV2Response,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    TakerBuySellVolumeResponse,
)

from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    Ticker24hrPriceChangeStatisticsResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    TopTraderLongShortRatioAccountsResponse,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    TopTraderLongShortRatioPositionsResponse,
)


from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    BasisContractTypeEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import BasisPeriodEnum
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    ContinuousContractKlineCandlestickDataContractTypeEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    ContinuousContractKlineCandlestickDataIntervalEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    IndexPriceKlineCandlestickDataIntervalEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    KlineCandlestickDataIntervalEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    LongShortRatioPeriodEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    MarkPriceKlineCandlestickDataIntervalEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    OpenInterestStatisticsPeriodEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    PremiumIndexKlineDataIntervalEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    TakerBuySellVolumePeriodEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    TopTraderLongShortRatioAccountsPeriodEnum,
)
from binance_sdk_derivatives_trading_usds_futures.rest_api.models import (
    TopTraderLongShortRatioPositionsPeriodEnum,
)


class TestMarketDataApi:
    @pytest.fixture(autouse=True)
    def setup_client(self):
        """Setup a client instance with mocked session before each test method."""
        self.mock_session = MagicMock(spec=requests.Session)
        config = ConfigurationRestAPI(
            api_key="test-api-key",
            api_secret="test-api-secret",
        )
        self.client = MarketDataApi(configuration=config, session=self.mock_session)

    def set_mock_response(self, data: dict = {}, status_code=200, headers=None):
        """Helper method to setup mock response for the client's session request."""
        if headers is None:
            headers = {}

        mock_response = MagicMock()
        mock_response.status_code = status_code
        mock_response.json.return_value = data
        mock_response.text = json.dumps(data)
        mock_response.headers = headers

        self.mock_session.request.return_value = mock_response

    def test_basis_success(self):
        """Test basis() successfully with required parameters only."""

        params = {
            "pair": "pair_example",
            "contract_type": BasisContractTypeEnum["PERPETUAL"].value,
            "period": BasisPeriodEnum["PERIOD_5m"].value,
            "limit": 30,
        }

        expected_response = [
            {
                "indexPrice": "34400.15945055",
                "contractType": "PERPETUAL",
                "basisRate": "0.0004",
                "futuresPrice": "34414.10",
                "annualizedBasisRate": "",
                "basis": "13.94054945",
                "pair": "BTCUSDT",
                "timestamp": 1698742800000,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.basis(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/futures/data/basis" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["pair"] == "pair_example"
        assert normalized["contractType"] == BasisContractTypeEnum["PERPETUAL"].value
        assert normalized["period"] == BasisPeriodEnum["PERIOD_5m"].value
        assert normalized["limit"] == 30

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(BasisResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(BasisResponse, "from_dict"):
            expected = BasisResponse.from_dict(expected_response)
        else:
            expected = BasisResponse.model_validate_json(json.dumps(expected_response))

        assert response.data() == expected

    def test_basis_success_with_optional_params(self):
        """Test basis() successfully with optional parameters."""

        params = {
            "pair": "pair_example",
            "contract_type": BasisContractTypeEnum["PERPETUAL"].value,
            "period": BasisPeriodEnum["PERIOD_5m"].value,
            "limit": 30,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
        }

        expected_response = [
            {
                "indexPrice": "34400.15945055",
                "contractType": "PERPETUAL",
                "basisRate": "0.0004",
                "futuresPrice": "34414.10",
                "annualizedBasisRate": "",
                "basis": "13.94054945",
                "pair": "BTCUSDT",
                "timestamp": 1698742800000,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.basis(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/futures/data/basis" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(BasisResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(BasisResponse, "from_dict"):
            expected = BasisResponse.from_dict(expected_response)
        else:
            expected = BasisResponse.model_validate_json(json.dumps(expected_response))

        assert response.data() == expected

    def test_basis_missing_required_param_pair(self):
        """Test that basis() raises RequiredError when 'pair' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": BasisContractTypeEnum["PERPETUAL"].value,
            "period": BasisPeriodEnum["PERIOD_5m"].value,
            "limit": 30,
        }
        params["pair"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'pair'"):
            self.client.basis(**params)

    def test_basis_missing_required_param_contract_type(self):
        """Test that basis() raises RequiredError when 'contract_type' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": BasisContractTypeEnum["PERPETUAL"].value,
            "period": BasisPeriodEnum["PERIOD_5m"].value,
            "limit": 30,
        }
        params["contract_type"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'contract_type'"
        ):
            self.client.basis(**params)

    def test_basis_missing_required_param_period(self):
        """Test that basis() raises RequiredError when 'period' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": BasisContractTypeEnum["PERPETUAL"].value,
            "period": BasisPeriodEnum["PERIOD_5m"].value,
            "limit": 30,
        }
        params["period"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'period'"):
            self.client.basis(**params)

    def test_basis_missing_required_param_limit(self):
        """Test that basis() raises RequiredError when 'limit' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": BasisContractTypeEnum["PERPETUAL"].value,
            "period": BasisPeriodEnum["PERIOD_5m"].value,
            "limit": 30,
        }
        params["limit"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'limit'"):
            self.client.basis(**params)

    def test_basis_server_error(self):
        """Test that basis() raises an error when the server returns an error."""

        params = {
            "pair": "pair_example",
            "contract_type": BasisContractTypeEnum["PERPETUAL"].value,
            "period": BasisPeriodEnum["PERIOD_5m"].value,
            "limit": 30,
        }

        mock_error = Exception("ResponseError")
        self.client.basis = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.basis(**params)

    def test_check_server_time_success(self):
        """Test check_server_time() successfully with required parameters only."""

        expected_response = {"serverTime": 1499827319559}

        self.set_mock_response(expected_response)

        response = self.client.check_server_time()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/time" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CheckServerTimeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(CheckServerTimeResponse, "from_dict"):
            expected = CheckServerTimeResponse.from_dict(expected_response)
        else:
            expected = CheckServerTimeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_check_server_time_server_error(self):
        """Test that check_server_time() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.check_server_time = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.check_server_time()

    def test_composite_index_symbol_information_success(self):
        """Test composite_index_symbol_information() successfully with required parameters only."""

        expected_response = [
            {
                "symbol": "DEFIUSDT",
                "time": 1589437530011,
                "component": "baseAsset",
                "baseAssetList": [
                    {
                        "baseAsset": "BAL",
                        "quoteAsset": "USDT",
                        "weightInQuantity": "1.04406228",
                        "weightInPercentage": "0.02783900",
                    },
                    {
                        "baseAsset": "BAND",
                        "quoteAsset": "USDT",
                        "weightInQuantity": "3.53782729",
                        "weightInPercentage": "0.03935200",
                    },
                ],
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.composite_index_symbol_information()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/indexInfo" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CompositeIndexSymbolInformationResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CompositeIndexSymbolInformationResponse, "from_dict")
        ):
            expected = CompositeIndexSymbolInformationResponse.from_dict(
                expected_response
            )
        else:
            expected = CompositeIndexSymbolInformationResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_composite_index_symbol_information_success_with_optional_params(self):
        """Test composite_index_symbol_information() successfully with optional parameters."""

        params = {"symbol": "symbol_example"}

        expected_response = [
            {
                "symbol": "DEFIUSDT",
                "time": 1589437530011,
                "component": "baseAsset",
                "baseAssetList": [
                    {
                        "baseAsset": "BAL",
                        "quoteAsset": "USDT",
                        "weightInQuantity": "1.04406228",
                        "weightInPercentage": "0.02783900",
                    },
                    {
                        "baseAsset": "BAND",
                        "quoteAsset": "USDT",
                        "weightInQuantity": "3.53782729",
                        "weightInPercentage": "0.03935200",
                    },
                ],
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.composite_index_symbol_information(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/indexInfo" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CompositeIndexSymbolInformationResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CompositeIndexSymbolInformationResponse, "from_dict")
        ):
            expected = CompositeIndexSymbolInformationResponse.from_dict(
                expected_response
            )
        else:
            expected = CompositeIndexSymbolInformationResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_composite_index_symbol_information_server_error(self):
        """Test that composite_index_symbol_information() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.composite_index_symbol_information = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.composite_index_symbol_information()

    def test_compressed_aggregate_trades_list_success(self):
        """Test compressed_aggregate_trades_list() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "a": 26129,
                "p": "0.01633102",
                "q": "4.70443515",
                "f": 27781,
                "l": 27781,
                "T": 1498793709153,
                "m": True,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.compressed_aggregate_trades_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/aggTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CompressedAggregateTradesListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CompressedAggregateTradesListResponse, "from_dict")
        ):
            expected = CompressedAggregateTradesListResponse.from_dict(
                expected_response
            )
        else:
            expected = CompressedAggregateTradesListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_compressed_aggregate_trades_list_success_with_optional_params(self):
        """Test compressed_aggregate_trades_list() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "from_id": 1,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
        }

        expected_response = [
            {
                "a": 26129,
                "p": "0.01633102",
                "q": "4.70443515",
                "f": 27781,
                "l": 27781,
                "T": 1498793709153,
                "m": True,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.compressed_aggregate_trades_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/aggTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(CompressedAggregateTradesListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(CompressedAggregateTradesListResponse, "from_dict")
        ):
            expected = CompressedAggregateTradesListResponse.from_dict(
                expected_response
            )
        else:
            expected = CompressedAggregateTradesListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_compressed_aggregate_trades_list_missing_required_param_symbol(self):
        """Test that compressed_aggregate_trades_list() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.compressed_aggregate_trades_list(**params)

    def test_compressed_aggregate_trades_list_server_error(self):
        """Test that compressed_aggregate_trades_list() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.compressed_aggregate_trades_list = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.compressed_aggregate_trades_list(**params)

    def test_continuous_contract_kline_candlestick_data_success(self):
        """Test continuous_contract_kline_candlestick_data() successfully with required parameters only."""

        params = {
            "pair": "pair_example",
            "contract_type": ContinuousContractKlineCandlestickDataContractTypeEnum[
                "PERPETUAL"
            ].value,
            "interval": ContinuousContractKlineCandlestickDataIntervalEnum[
                "INTERVAL_1m"
            ].value,
        }

        expected_response = [
            [
                1607444700000,
                "18879.99",
                "18900.00",
                "18878.98",
                "18896.13",
                "492.363",
                1607444759999,
                "9302145.66080",
                1874,
                "385.983",
                "7292402.33267",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.continuous_contract_kline_candlestick_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/continuousKlines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["pair"] == "pair_example"
        assert (
            normalized["contractType"]
            == ContinuousContractKlineCandlestickDataContractTypeEnum["PERPETUAL"].value
        )
        assert (
            normalized["interval"]
            == ContinuousContractKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ContinuousContractKlineCandlestickDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(ContinuousContractKlineCandlestickDataResponse, "from_dict")
        ):
            expected = ContinuousContractKlineCandlestickDataResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                ContinuousContractKlineCandlestickDataResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    def test_continuous_contract_kline_candlestick_data_success_with_optional_params(
        self,
    ):
        """Test continuous_contract_kline_candlestick_data() successfully with optional parameters."""

        params = {
            "pair": "pair_example",
            "contract_type": ContinuousContractKlineCandlestickDataContractTypeEnum[
                "PERPETUAL"
            ].value,
            "interval": ContinuousContractKlineCandlestickDataIntervalEnum[
                "INTERVAL_1m"
            ].value,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
        }

        expected_response = [
            [
                1607444700000,
                "18879.99",
                "18900.00",
                "18878.98",
                "18896.13",
                "492.363",
                1607444759999,
                "9302145.66080",
                1874,
                "385.983",
                "7292402.33267",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.continuous_contract_kline_candlestick_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/continuousKlines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ContinuousContractKlineCandlestickDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(ContinuousContractKlineCandlestickDataResponse, "from_dict")
        ):
            expected = ContinuousContractKlineCandlestickDataResponse.from_dict(
                expected_response
            )
        else:
            expected = (
                ContinuousContractKlineCandlestickDataResponse.model_validate_json(
                    json.dumps(expected_response)
                )
            )

        assert response.data() == expected

    def test_continuous_contract_kline_candlestick_data_missing_required_param_pair(
        self,
    ):
        """Test that continuous_contract_kline_candlestick_data() raises RequiredError when 'pair' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": ContinuousContractKlineCandlestickDataContractTypeEnum[
                "PERPETUAL"
            ].value,
            "interval": ContinuousContractKlineCandlestickDataIntervalEnum[
                "INTERVAL_1m"
            ].value,
        }
        params["pair"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'pair'"):
            self.client.continuous_contract_kline_candlestick_data(**params)

    def test_continuous_contract_kline_candlestick_data_missing_required_param_contract_type(
        self,
    ):
        """Test that continuous_contract_kline_candlestick_data() raises RequiredError when 'contract_type' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": ContinuousContractKlineCandlestickDataContractTypeEnum[
                "PERPETUAL"
            ].value,
            "interval": ContinuousContractKlineCandlestickDataIntervalEnum[
                "INTERVAL_1m"
            ].value,
        }
        params["contract_type"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'contract_type'"
        ):
            self.client.continuous_contract_kline_candlestick_data(**params)

    def test_continuous_contract_kline_candlestick_data_missing_required_param_interval(
        self,
    ):
        """Test that continuous_contract_kline_candlestick_data() raises RequiredError when 'interval' is missing."""
        params = {
            "pair": "pair_example",
            "contract_type": ContinuousContractKlineCandlestickDataContractTypeEnum[
                "PERPETUAL"
            ].value,
            "interval": ContinuousContractKlineCandlestickDataIntervalEnum[
                "INTERVAL_1m"
            ].value,
        }
        params["interval"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'interval'"
        ):
            self.client.continuous_contract_kline_candlestick_data(**params)

    def test_continuous_contract_kline_candlestick_data_server_error(self):
        """Test that continuous_contract_kline_candlestick_data() raises an error when the server returns an error."""

        params = {
            "pair": "pair_example",
            "contract_type": ContinuousContractKlineCandlestickDataContractTypeEnum[
                "PERPETUAL"
            ].value,
            "interval": ContinuousContractKlineCandlestickDataIntervalEnum[
                "INTERVAL_1m"
            ].value,
        }

        mock_error = Exception("ResponseError")
        self.client.continuous_contract_kline_candlestick_data = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.continuous_contract_kline_candlestick_data(**params)

    def test_exchange_information_success(self):
        """Test exchange_information() successfully with required parameters only."""

        expected_response = {
            "exchangeFilters": [],
            "rateLimits": [
                {
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 2400,
                    "rateLimitType": "REQUEST_WEIGHT",
                },
                {
                    "interval": "MINUTE",
                    "intervalNum": 1,
                    "limit": 1200,
                    "rateLimitType": "ORDERS",
                },
            ],
            "serverTime": 1565613908500,
            "assets": [
                {"asset": "BTC", "marginAvailable": True, "autoAssetExchange": "-0.10"},
                {"asset": "USDT", "marginAvailable": True, "autoAssetExchange": "0"},
                {"asset": "BNB", "marginAvailable": False, "autoAssetExchange": None},
            ],
            "symbols": [
                {
                    "symbol": "BLZUSDT",
                    "pair": "BLZUSDT",
                    "contractType": "PERPETUAL",
                    "deliveryDate": 4133404800000,
                    "onboardDate": 1598252400000,
                    "status": "TRADING",
                    "maintMarginPercent": "2.5000",
                    "requiredMarginPercent": "5.0000",
                    "baseAsset": "BLZ",
                    "quoteAsset": "USDT",
                    "marginAsset": "USDT",
                    "pricePrecision": 5,
                    "quantityPrecision": 0,
                    "baseAssetPrecision": 8,
                    "quotePrecision": 8,
                    "underlyingType": "COIN",
                    "underlyingSubType": ["STORAGE"],
                    "settlePlan": 0,
                    "triggerProtect": "0.15",
                    "filters": [
                        {
                            "filterType": "PRICE_FILTER",
                            "maxPrice": "300",
                            "minPrice": "0.0001",
                            "tickSize": "0.0001",
                        },
                        {
                            "filterType": "LOT_SIZE",
                            "maxQty": "10000000",
                            "minQty": "1",
                            "stepSize": "1",
                        },
                        {
                            "filterType": "MARKET_LOT_SIZE",
                            "maxQty": "590119",
                            "minQty": "1",
                            "stepSize": "1",
                        },
                        {"filterType": "MAX_NUM_ORDERS", "limit": 200},
                        {"filterType": "MAX_NUM_ALGO_ORDERS", "limit": 10},
                        {"filterType": "MIN_NOTIONAL", "notional": "5.0"},
                        {
                            "filterType": "PERCENT_PRICE",
                            "multiplierUp": "1.1500",
                            "multiplierDown": "0.8500",
                            "multiplierDecimal": "4",
                        },
                    ],
                    "OrderType": [
                        "LIMIT",
                        "MARKET",
                        "STOP",
                        "STOP_MARKET",
                        "TAKE_PROFIT",
                        "TAKE_PROFIT_MARKET",
                        "TRAILING_STOP_MARKET",
                    ],
                    "timeInForce": ["GTC", "IOC", "FOK", "GTX"],
                    "liquidationFee": "0.010000",
                    "marketTakeBound": "0.30",
                }
            ],
            "timezone": "UTC",
        }

        self.set_mock_response(expected_response)

        response = self.client.exchange_information()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/exchangeInfo" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(ExchangeInformationResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(ExchangeInformationResponse, "from_dict"):
            expected = ExchangeInformationResponse.from_dict(expected_response)
        else:
            expected = ExchangeInformationResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_exchange_information_server_error(self):
        """Test that exchange_information() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.exchange_information = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.exchange_information()

    def test_get_funding_rate_history_success(self):
        """Test get_funding_rate_history() successfully with required parameters only."""

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "fundingRate": "-0.03750000",
                "fundingTime": 1570608000000,
                "markPrice": "34287.54619963",
            },
            {
                "symbol": "BTCUSDT",
                "fundingRate": "0.00010000",
                "fundingTime": 1570636800000,
                "markPrice": "34287.54619963",
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.get_funding_rate_history()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/fundingRate" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetFundingRateHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(GetFundingRateHistoryResponse, "from_dict"):
            expected = GetFundingRateHistoryResponse.from_dict(expected_response)
        else:
            expected = GetFundingRateHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_funding_rate_history_success_with_optional_params(self):
        """Test get_funding_rate_history() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "fundingRate": "-0.03750000",
                "fundingTime": 1570608000000,
                "markPrice": "34287.54619963",
            },
            {
                "symbol": "BTCUSDT",
                "fundingRate": "0.00010000",
                "fundingTime": 1570636800000,
                "markPrice": "34287.54619963",
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.get_funding_rate_history(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/fundingRate" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetFundingRateHistoryResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(GetFundingRateHistoryResponse, "from_dict"):
            expected = GetFundingRateHistoryResponse.from_dict(expected_response)
        else:
            expected = GetFundingRateHistoryResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_funding_rate_history_server_error(self):
        """Test that get_funding_rate_history() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.get_funding_rate_history = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_funding_rate_history()

    def test_get_funding_rate_info_success(self):
        """Test get_funding_rate_info() successfully with required parameters only."""

        expected_response = [
            {
                "symbol": "BLZUSDT",
                "adjustedFundingRateCap": "0.02500000",
                "adjustedFundingRateFloor": "-0.02500000",
                "fundingIntervalHours": 8,
                "disclaimer": False,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.get_funding_rate_info()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/fundingInfo" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(GetFundingRateInfoResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(GetFundingRateInfoResponse, "from_dict"):
            expected = GetFundingRateInfoResponse.from_dict(expected_response)
        else:
            expected = GetFundingRateInfoResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_get_funding_rate_info_server_error(self):
        """Test that get_funding_rate_info() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.get_funding_rate_info = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.get_funding_rate_info()

    def test_index_price_kline_candlestick_data_success(self):
        """Test index_price_kline_candlestick_data() successfully with required parameters only."""

        params = {
            "pair": "pair_example",
            "interval": IndexPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }

        expected_response = [
            [
                1591256400000,
                "9653.69440000",
                "9653.69640000",
                "9651.38600000",
                "9651.55200000",
                "0",
                1591256459999,
                "0",
                60,
                "0",
                "0",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.index_price_kline_candlestick_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/indexPriceKlines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["pair"] == "pair_example"
        assert (
            normalized["interval"]
            == IndexPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(IndexPriceKlineCandlestickDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(IndexPriceKlineCandlestickDataResponse, "from_dict")
        ):
            expected = IndexPriceKlineCandlestickDataResponse.from_dict(
                expected_response
            )
        else:
            expected = IndexPriceKlineCandlestickDataResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_index_price_kline_candlestick_data_success_with_optional_params(self):
        """Test index_price_kline_candlestick_data() successfully with optional parameters."""

        params = {
            "pair": "pair_example",
            "interval": IndexPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
        }

        expected_response = [
            [
                1591256400000,
                "9653.69440000",
                "9653.69640000",
                "9651.38600000",
                "9651.55200000",
                "0",
                1591256459999,
                "0",
                60,
                "0",
                "0",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.index_price_kline_candlestick_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/indexPriceKlines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(IndexPriceKlineCandlestickDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(IndexPriceKlineCandlestickDataResponse, "from_dict")
        ):
            expected = IndexPriceKlineCandlestickDataResponse.from_dict(
                expected_response
            )
        else:
            expected = IndexPriceKlineCandlestickDataResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_index_price_kline_candlestick_data_missing_required_param_pair(self):
        """Test that index_price_kline_candlestick_data() raises RequiredError when 'pair' is missing."""
        params = {
            "pair": "pair_example",
            "interval": IndexPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }
        params["pair"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'pair'"):
            self.client.index_price_kline_candlestick_data(**params)

    def test_index_price_kline_candlestick_data_missing_required_param_interval(self):
        """Test that index_price_kline_candlestick_data() raises RequiredError when 'interval' is missing."""
        params = {
            "pair": "pair_example",
            "interval": IndexPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }
        params["interval"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'interval'"
        ):
            self.client.index_price_kline_candlestick_data(**params)

    def test_index_price_kline_candlestick_data_server_error(self):
        """Test that index_price_kline_candlestick_data() raises an error when the server returns an error."""

        params = {
            "pair": "pair_example",
            "interval": IndexPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.index_price_kline_candlestick_data = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.index_price_kline_candlestick_data(**params)

    def test_kline_candlestick_data_success(self):
        """Test kline_candlestick_data() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "interval": KlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }

        expected_response = [
            [
                1499040000000,
                "0.01634790",
                "0.80000000",
                "0.01575800",
                "0.01577100",
                "148976.11427815",
                1499644799999,
                "2434.19055334",
                308,
                "1756.87402397",
                "28.46694368",
                "17928899.62484339",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.kline_candlestick_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/klines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"
        assert (
            normalized["interval"]
            == KlineCandlestickDataIntervalEnum["INTERVAL_1m"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(KlineCandlestickDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(KlineCandlestickDataResponse, "from_dict"):
            expected = KlineCandlestickDataResponse.from_dict(expected_response)
        else:
            expected = KlineCandlestickDataResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_kline_candlestick_data_success_with_optional_params(self):
        """Test kline_candlestick_data() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "interval": KlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
        }

        expected_response = [
            [
                1499040000000,
                "0.01634790",
                "0.80000000",
                "0.01575800",
                "0.01577100",
                "148976.11427815",
                1499644799999,
                "2434.19055334",
                308,
                "1756.87402397",
                "28.46694368",
                "17928899.62484339",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.kline_candlestick_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/klines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(KlineCandlestickDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(KlineCandlestickDataResponse, "from_dict"):
            expected = KlineCandlestickDataResponse.from_dict(expected_response)
        else:
            expected = KlineCandlestickDataResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_kline_candlestick_data_missing_required_param_symbol(self):
        """Test that kline_candlestick_data() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "interval": KlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.kline_candlestick_data(**params)

    def test_kline_candlestick_data_missing_required_param_interval(self):
        """Test that kline_candlestick_data() raises RequiredError when 'interval' is missing."""
        params = {
            "symbol": "symbol_example",
            "interval": KlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }
        params["interval"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'interval'"
        ):
            self.client.kline_candlestick_data(**params)

    def test_kline_candlestick_data_server_error(self):
        """Test that kline_candlestick_data() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "interval": KlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.kline_candlestick_data = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.kline_candlestick_data(**params)

    def test_long_short_ratio_success(self):
        """Test long_short_ratio() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "period": LongShortRatioPeriodEnum["PERIOD_5m"].value,
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "longShortRatio": "0.1960",
                "longAccount": "0.6622",
                "shortAccount": "0.3378",
                "timestamp": "1583139600000",
            },
            {
                "symbol": "BTCUSDT",
                "longShortRatio": "1.9559",
                "longAccount": "0.6617",
                "shortAccount": "0.3382",
                "timestamp": "1583139900000",
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.long_short_ratio(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/futures/data/globalLongShortAccountRatio" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["period"] == LongShortRatioPeriodEnum["PERIOD_5m"].value

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(LongShortRatioResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(LongShortRatioResponse, "from_dict"):
            expected = LongShortRatioResponse.from_dict(expected_response)
        else:
            expected = LongShortRatioResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_long_short_ratio_success_with_optional_params(self):
        """Test long_short_ratio() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "period": LongShortRatioPeriodEnum["PERIOD_5m"].value,
            "limit": 100,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "longShortRatio": "0.1960",
                "longAccount": "0.6622",
                "shortAccount": "0.3378",
                "timestamp": "1583139600000",
            },
            {
                "symbol": "BTCUSDT",
                "longShortRatio": "1.9559",
                "longAccount": "0.6617",
                "shortAccount": "0.3382",
                "timestamp": "1583139900000",
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.long_short_ratio(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/futures/data/globalLongShortAccountRatio" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(LongShortRatioResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(LongShortRatioResponse, "from_dict"):
            expected = LongShortRatioResponse.from_dict(expected_response)
        else:
            expected = LongShortRatioResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_long_short_ratio_missing_required_param_symbol(self):
        """Test that long_short_ratio() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "period": LongShortRatioPeriodEnum["PERIOD_5m"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.long_short_ratio(**params)

    def test_long_short_ratio_missing_required_param_period(self):
        """Test that long_short_ratio() raises RequiredError when 'period' is missing."""
        params = {
            "symbol": "symbol_example",
            "period": LongShortRatioPeriodEnum["PERIOD_5m"].value,
        }
        params["period"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'period'"):
            self.client.long_short_ratio(**params)

    def test_long_short_ratio_server_error(self):
        """Test that long_short_ratio() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "period": LongShortRatioPeriodEnum["PERIOD_5m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.long_short_ratio = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.long_short_ratio(**params)

    def test_mark_price_success(self):
        """Test mark_price() successfully with required parameters only."""

        expected_response = {
            "symbol": "BTCUSDT",
            "markPrice": "11793.63104562",
            "indexPrice": "11781.80495970",
            "estimatedSettlePrice": "11781.16138815",
            "lastFundingRate": "0.00038246",
            "interestRate": "0.00010000",
            "nextFundingTime": 1597392000000,
            "time": 1597370495002,
        }

        self.set_mock_response(expected_response)

        response = self.client.mark_price()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/premiumIndex" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarkPriceResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(MarkPriceResponse, "from_dict"):
            expected = MarkPriceResponse.from_dict(expected_response)
        else:
            expected = MarkPriceResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_mark_price_success_with_optional_params(self):
        """Test mark_price() successfully with optional parameters."""

        params = {"symbol": "symbol_example"}

        expected_response = {
            "symbol": "BTCUSDT",
            "markPrice": "11793.63104562",
            "indexPrice": "11781.80495970",
            "estimatedSettlePrice": "11781.16138815",
            "lastFundingRate": "0.00038246",
            "interestRate": "0.00010000",
            "nextFundingTime": 1597392000000,
            "time": 1597370495002,
        }

        self.set_mock_response(expected_response)

        response = self.client.mark_price(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/premiumIndex" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarkPriceResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(MarkPriceResponse, "from_dict"):
            expected = MarkPriceResponse.from_dict(expected_response)
        else:
            expected = MarkPriceResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_mark_price_server_error(self):
        """Test that mark_price() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.mark_price = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.mark_price()

    def test_mark_price_kline_candlestick_data_success(self):
        """Test mark_price_kline_candlestick_data() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "interval": MarkPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }

        expected_response = [
            [
                1591256460000,
                "9653.29201333",
                "9654.56401333",
                "9653.07367333",
                "9653.07367333",
                "0",
                1591256519999,
                "0",
                60,
                "0",
                "0",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.mark_price_kline_candlestick_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/markPriceKlines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"
        assert (
            normalized["interval"]
            == MarkPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarkPriceKlineCandlestickDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(MarkPriceKlineCandlestickDataResponse, "from_dict")
        ):
            expected = MarkPriceKlineCandlestickDataResponse.from_dict(
                expected_response
            )
        else:
            expected = MarkPriceKlineCandlestickDataResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_mark_price_kline_candlestick_data_success_with_optional_params(self):
        """Test mark_price_kline_candlestick_data() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "interval": MarkPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
        }

        expected_response = [
            [
                1591256460000,
                "9653.29201333",
                "9654.56401333",
                "9653.07367333",
                "9653.07367333",
                "0",
                1591256519999,
                "0",
                60,
                "0",
                "0",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.mark_price_kline_candlestick_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/markPriceKlines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MarkPriceKlineCandlestickDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(MarkPriceKlineCandlestickDataResponse, "from_dict")
        ):
            expected = MarkPriceKlineCandlestickDataResponse.from_dict(
                expected_response
            )
        else:
            expected = MarkPriceKlineCandlestickDataResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_mark_price_kline_candlestick_data_missing_required_param_symbol(self):
        """Test that mark_price_kline_candlestick_data() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "interval": MarkPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.mark_price_kline_candlestick_data(**params)

    def test_mark_price_kline_candlestick_data_missing_required_param_interval(self):
        """Test that mark_price_kline_candlestick_data() raises RequiredError when 'interval' is missing."""
        params = {
            "symbol": "symbol_example",
            "interval": MarkPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }
        params["interval"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'interval'"
        ):
            self.client.mark_price_kline_candlestick_data(**params)

    def test_mark_price_kline_candlestick_data_server_error(self):
        """Test that mark_price_kline_candlestick_data() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "interval": MarkPriceKlineCandlestickDataIntervalEnum["INTERVAL_1m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.mark_price_kline_candlestick_data = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.mark_price_kline_candlestick_data(**params)

    def test_multi_assets_mode_asset_index_success(self):
        """Test multi_assets_mode_asset_index() successfully with required parameters only."""

        expected_response = {
            "symbol": "ADAUSD",
            "time": 1635740268004,
            "index": "1.92957370",
            "bidBuffer": "0.10000000",
            "askBuffer": "0.10000000",
            "bidRate": "1.73661633",
            "askRate": "2.12253107",
            "autoExchangeBidBuffer": "0.05000000",
            "autoExchangeAskBuffer": "0.05000000",
            "autoExchangeBidRate": "1.83309501",
            "autoExchangeAskRate": "2.02605238",
        }

        self.set_mock_response(expected_response)

        response = self.client.multi_assets_mode_asset_index()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/assetIndex" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MultiAssetsModeAssetIndexResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(MultiAssetsModeAssetIndexResponse, "from_dict")
        ):
            expected = MultiAssetsModeAssetIndexResponse.from_dict(expected_response)
        else:
            expected = MultiAssetsModeAssetIndexResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_multi_assets_mode_asset_index_success_with_optional_params(self):
        """Test multi_assets_mode_asset_index() successfully with optional parameters."""

        params = {"symbol": "symbol_example"}

        expected_response = {
            "symbol": "ADAUSD",
            "time": 1635740268004,
            "index": "1.92957370",
            "bidBuffer": "0.10000000",
            "askBuffer": "0.10000000",
            "bidRate": "1.73661633",
            "askRate": "2.12253107",
            "autoExchangeBidBuffer": "0.05000000",
            "autoExchangeAskBuffer": "0.05000000",
            "autoExchangeBidRate": "1.83309501",
            "autoExchangeAskRate": "2.02605238",
        }

        self.set_mock_response(expected_response)

        response = self.client.multi_assets_mode_asset_index(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/assetIndex" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(MultiAssetsModeAssetIndexResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(MultiAssetsModeAssetIndexResponse, "from_dict")
        ):
            expected = MultiAssetsModeAssetIndexResponse.from_dict(expected_response)
        else:
            expected = MultiAssetsModeAssetIndexResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_multi_assets_mode_asset_index_server_error(self):
        """Test that multi_assets_mode_asset_index() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.multi_assets_mode_asset_index = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.multi_assets_mode_asset_index()

    def test_old_trades_lookup_success(self):
        """Test old_trades_lookup() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "id": 28457,
                "price": "4.00000100",
                "qty": "12.00000000",
                "quoteQty": "8000.00",
                "time": 1499865549590,
                "isBuyerMaker": True,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.old_trades_lookup(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/historicalTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OldTradesLookupResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(OldTradesLookupResponse, "from_dict"):
            expected = OldTradesLookupResponse.from_dict(expected_response)
        else:
            expected = OldTradesLookupResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_old_trades_lookup_success_with_optional_params(self):
        """Test old_trades_lookup() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "limit": 100, "from_id": 1}

        expected_response = [
            {
                "id": 28457,
                "price": "4.00000100",
                "qty": "12.00000000",
                "quoteQty": "8000.00",
                "time": 1499865549590,
                "isBuyerMaker": True,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.old_trades_lookup(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/historicalTrades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OldTradesLookupResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(OldTradesLookupResponse, "from_dict"):
            expected = OldTradesLookupResponse.from_dict(expected_response)
        else:
            expected = OldTradesLookupResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_old_trades_lookup_missing_required_param_symbol(self):
        """Test that old_trades_lookup() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.old_trades_lookup(**params)

    def test_old_trades_lookup_server_error(self):
        """Test that old_trades_lookup() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.old_trades_lookup = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.old_trades_lookup(**params)

    def test_open_interest_success(self):
        """Test open_interest() successfully with required parameters only."""

        params = {"symbol": "symbol_example"}

        expected_response = {
            "openInterest": "10659.509",
            "symbol": "BTCUSDT",
            "time": 1589437530011,
        }

        self.set_mock_response(expected_response)

        response = self.client.open_interest(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/openInterest" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OpenInterestResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(OpenInterestResponse, "from_dict"):
            expected = OpenInterestResponse.from_dict(expected_response)
        else:
            expected = OpenInterestResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_open_interest_success_with_optional_params(self):
        """Test open_interest() successfully with optional parameters."""

        params = {"symbol": "symbol_example"}

        expected_response = {
            "openInterest": "10659.509",
            "symbol": "BTCUSDT",
            "time": 1589437530011,
        }

        self.set_mock_response(expected_response)

        response = self.client.open_interest(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/openInterest" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OpenInterestResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(OpenInterestResponse, "from_dict"):
            expected = OpenInterestResponse.from_dict(expected_response)
        else:
            expected = OpenInterestResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_open_interest_missing_required_param_symbol(self):
        """Test that open_interest() raises RequiredError when 'symbol' is missing."""
        params = {"symbol": "symbol_example"}
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.open_interest(**params)

    def test_open_interest_server_error(self):
        """Test that open_interest() raises an error when the server returns an error."""

        params = {"symbol": "symbol_example"}

        mock_error = Exception("ResponseError")
        self.client.open_interest = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.open_interest(**params)

    def test_open_interest_statistics_success(self):
        """Test open_interest_statistics() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "period": OpenInterestStatisticsPeriodEnum["PERIOD_5m"].value,
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "sumOpenInterest": "20403.63700000",
                "sumOpenInterestValue": "150570784.07809979",
                "CMCCirculatingSupply": "165880.538",
                "timestamp": "1583127900000",
            },
            {
                "symbol": "BTCUSDT",
                "sumOpenInterest": "20401.36700000",
                "sumOpenInterestValue": "149940752.14464448",
                "CMCCirculatingSupply": "165900.14853",
                "timestamp": "1583128200000",
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.open_interest_statistics(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/futures/data/openInterestHist" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"
        assert (
            normalized["period"] == OpenInterestStatisticsPeriodEnum["PERIOD_5m"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OpenInterestStatisticsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(OpenInterestStatisticsResponse, "from_dict")
        ):
            expected = OpenInterestStatisticsResponse.from_dict(expected_response)
        else:
            expected = OpenInterestStatisticsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_open_interest_statistics_success_with_optional_params(self):
        """Test open_interest_statistics() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "period": OpenInterestStatisticsPeriodEnum["PERIOD_5m"].value,
            "limit": 100,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "sumOpenInterest": "20403.63700000",
                "sumOpenInterestValue": "150570784.07809979",
                "CMCCirculatingSupply": "165880.538",
                "timestamp": "1583127900000",
            },
            {
                "symbol": "BTCUSDT",
                "sumOpenInterest": "20401.36700000",
                "sumOpenInterestValue": "149940752.14464448",
                "CMCCirculatingSupply": "165900.14853",
                "timestamp": "1583128200000",
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.open_interest_statistics(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/futures/data/openInterestHist" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OpenInterestStatisticsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof or is_list or hasattr(OpenInterestStatisticsResponse, "from_dict")
        ):
            expected = OpenInterestStatisticsResponse.from_dict(expected_response)
        else:
            expected = OpenInterestStatisticsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_open_interest_statistics_missing_required_param_symbol(self):
        """Test that open_interest_statistics() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "period": OpenInterestStatisticsPeriodEnum["PERIOD_5m"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.open_interest_statistics(**params)

    def test_open_interest_statistics_missing_required_param_period(self):
        """Test that open_interest_statistics() raises RequiredError when 'period' is missing."""
        params = {
            "symbol": "symbol_example",
            "period": OpenInterestStatisticsPeriodEnum["PERIOD_5m"].value,
        }
        params["period"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'period'"):
            self.client.open_interest_statistics(**params)

    def test_open_interest_statistics_server_error(self):
        """Test that open_interest_statistics() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "period": OpenInterestStatisticsPeriodEnum["PERIOD_5m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.open_interest_statistics = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.open_interest_statistics(**params)

    def test_order_book_success(self):
        """Test order_book() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = {
            "lastUpdateId": 1027024,
            "E": 1589436922972,
            "T": 1589436922959,
            "bids": [["4.00000000", "431.00000000"]],
            "asks": [["4.00000200", "12.00000000"]],
        }

        self.set_mock_response(expected_response)

        response = self.client.order_book(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/depth" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderBookResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(OrderBookResponse, "from_dict"):
            expected = OrderBookResponse.from_dict(expected_response)
        else:
            expected = OrderBookResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_order_book_success_with_optional_params(self):
        """Test order_book() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "limit": 100}

        expected_response = {
            "lastUpdateId": 1027024,
            "E": 1589436922972,
            "T": 1589436922959,
            "bids": [["4.00000000", "431.00000000"]],
            "asks": [["4.00000200", "12.00000000"]],
        }

        self.set_mock_response(expected_response)

        response = self.client.order_book(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/depth" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(OrderBookResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(OrderBookResponse, "from_dict"):
            expected = OrderBookResponse.from_dict(expected_response)
        else:
            expected = OrderBookResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_order_book_missing_required_param_symbol(self):
        """Test that order_book() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.order_book(**params)

    def test_order_book_server_error(self):
        """Test that order_book() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.order_book = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.order_book(**params)

    def test_premium_index_kline_data_success(self):
        """Test premium_index_kline_data() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "interval": PremiumIndexKlineDataIntervalEnum["INTERVAL_1m"].value,
        }

        expected_response = [
            [
                1691603820000,
                "-0.00042931",
                "-0.00023641",
                "-0.00059406",
                "-0.00043659",
                "0",
                1691603879999,
                "0",
                12,
                "0",
                "0",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.premium_index_kline_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/premiumIndexKlines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"
        assert (
            normalized["interval"]
            == PremiumIndexKlineDataIntervalEnum["INTERVAL_1m"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(PremiumIndexKlineDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(PremiumIndexKlineDataResponse, "from_dict"):
            expected = PremiumIndexKlineDataResponse.from_dict(expected_response)
        else:
            expected = PremiumIndexKlineDataResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_premium_index_kline_data_success_with_optional_params(self):
        """Test premium_index_kline_data() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "interval": PremiumIndexKlineDataIntervalEnum["INTERVAL_1m"].value,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
            "limit": 100,
        }

        expected_response = [
            [
                1691603820000,
                "-0.00042931",
                "-0.00023641",
                "-0.00059406",
                "-0.00043659",
                "0",
                1691603879999,
                "0",
                12,
                "0",
                "0",
                "0",
            ]
        ]

        self.set_mock_response(expected_response)

        response = self.client.premium_index_kline_data(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/premiumIndexKlines" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(PremiumIndexKlineDataResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(PremiumIndexKlineDataResponse, "from_dict"):
            expected = PremiumIndexKlineDataResponse.from_dict(expected_response)
        else:
            expected = PremiumIndexKlineDataResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_premium_index_kline_data_missing_required_param_symbol(self):
        """Test that premium_index_kline_data() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "interval": PremiumIndexKlineDataIntervalEnum["INTERVAL_1m"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.premium_index_kline_data(**params)

    def test_premium_index_kline_data_missing_required_param_interval(self):
        """Test that premium_index_kline_data() raises RequiredError when 'interval' is missing."""
        params = {
            "symbol": "symbol_example",
            "interval": PremiumIndexKlineDataIntervalEnum["INTERVAL_1m"].value,
        }
        params["interval"] = None

        with pytest.raises(
            RequiredError, match="Missing required parameter 'interval'"
        ):
            self.client.premium_index_kline_data(**params)

    def test_premium_index_kline_data_server_error(self):
        """Test that premium_index_kline_data() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "interval": PremiumIndexKlineDataIntervalEnum["INTERVAL_1m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.premium_index_kline_data = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.premium_index_kline_data(**params)

    def test_quarterly_contract_settlement_price_success(self):
        """Test quarterly_contract_settlement_price() successfully with required parameters only."""

        params = {"pair": "pair_example"}

        expected_response = [
            {"deliveryTime": 1695945600000, "deliveryPrice": 27103},
            {"deliveryTime": 1688083200000, "deliveryPrice": 30733.6},
            {"deliveryTime": 1680220800000, "deliveryPrice": 27814.2},
            {"deliveryTime": 1648166400000, "deliveryPrice": 44066.3},
        ]

        self.set_mock_response(expected_response)

        response = self.client.quarterly_contract_settlement_price(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/futures/data/delivery-price" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["pair"] == "pair_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QuarterlyContractSettlementPriceResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QuarterlyContractSettlementPriceResponse, "from_dict")
        ):
            expected = QuarterlyContractSettlementPriceResponse.from_dict(
                expected_response
            )
        else:
            expected = QuarterlyContractSettlementPriceResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_quarterly_contract_settlement_price_success_with_optional_params(self):
        """Test quarterly_contract_settlement_price() successfully with optional parameters."""

        params = {"pair": "pair_example"}

        expected_response = [
            {"deliveryTime": 1695945600000, "deliveryPrice": 27103},
            {"deliveryTime": 1688083200000, "deliveryPrice": 30733.6},
            {"deliveryTime": 1680220800000, "deliveryPrice": 27814.2},
            {"deliveryTime": 1648166400000, "deliveryPrice": 44066.3},
        ]

        self.set_mock_response(expected_response)

        response = self.client.quarterly_contract_settlement_price(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/futures/data/delivery-price" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QuarterlyContractSettlementPriceResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QuarterlyContractSettlementPriceResponse, "from_dict")
        ):
            expected = QuarterlyContractSettlementPriceResponse.from_dict(
                expected_response
            )
        else:
            expected = QuarterlyContractSettlementPriceResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_quarterly_contract_settlement_price_missing_required_param_pair(self):
        """Test that quarterly_contract_settlement_price() raises RequiredError when 'pair' is missing."""
        params = {"pair": "pair_example"}
        params["pair"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'pair'"):
            self.client.quarterly_contract_settlement_price(**params)

    def test_quarterly_contract_settlement_price_server_error(self):
        """Test that quarterly_contract_settlement_price() raises an error when the server returns an error."""

        params = {"pair": "pair_example"}

        mock_error = Exception("ResponseError")
        self.client.quarterly_contract_settlement_price = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.quarterly_contract_settlement_price(**params)

    def test_query_index_price_constituents_success(self):
        """Test query_index_price_constituents() successfully with required parameters only."""

        params = {"symbol": "symbol_example"}

        expected_response = {
            "symbol": "BTCUSDT",
            "time": 1745401553408,
            "constituents": [
                {
                    "exchange": "binance",
                    "symbol": "BTCUSDT",
                    "price": "94057.03000000",
                    "weight": "0.51282051",
                },
                {
                    "exchange": "coinbase",
                    "symbol": "BTC-USDT",
                    "price": "94140.58000000",
                    "weight": "0.15384615",
                },
                {
                    "exchange": "gateio",
                    "symbol": "BTC_USDT",
                    "price": "94060.10000000",
                    "weight": "0.02564103",
                },
                {
                    "exchange": "kucoin",
                    "symbol": "BTC-USDT",
                    "price": "94096.70000000",
                    "weight": "0.07692308",
                },
                {
                    "exchange": "mxc",
                    "symbol": "BTCUSDT",
                    "price": "94057.02000000",
                    "weight": "0.07692308",
                },
                {
                    "exchange": "bitget",
                    "symbol": "BTCUSDT",
                    "price": "94064.03000000",
                    "weight": "0.07692308",
                },
                {
                    "exchange": "bybit",
                    "symbol": "BTCUSDT",
                    "price": "94067.90000000",
                    "weight": "0.07692308",
                },
            ],
        }

        self.set_mock_response(expected_response)

        response = self.client.query_index_price_constituents(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/constituents" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryIndexPriceConstituentsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryIndexPriceConstituentsResponse, "from_dict")
        ):
            expected = QueryIndexPriceConstituentsResponse.from_dict(expected_response)
        else:
            expected = QueryIndexPriceConstituentsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_index_price_constituents_success_with_optional_params(self):
        """Test query_index_price_constituents() successfully with optional parameters."""

        params = {"symbol": "symbol_example"}

        expected_response = {
            "symbol": "BTCUSDT",
            "time": 1745401553408,
            "constituents": [
                {
                    "exchange": "binance",
                    "symbol": "BTCUSDT",
                    "price": "94057.03000000",
                    "weight": "0.51282051",
                },
                {
                    "exchange": "coinbase",
                    "symbol": "BTC-USDT",
                    "price": "94140.58000000",
                    "weight": "0.15384615",
                },
                {
                    "exchange": "gateio",
                    "symbol": "BTC_USDT",
                    "price": "94060.10000000",
                    "weight": "0.02564103",
                },
                {
                    "exchange": "kucoin",
                    "symbol": "BTC-USDT",
                    "price": "94096.70000000",
                    "weight": "0.07692308",
                },
                {
                    "exchange": "mxc",
                    "symbol": "BTCUSDT",
                    "price": "94057.02000000",
                    "weight": "0.07692308",
                },
                {
                    "exchange": "bitget",
                    "symbol": "BTCUSDT",
                    "price": "94064.03000000",
                    "weight": "0.07692308",
                },
                {
                    "exchange": "bybit",
                    "symbol": "BTCUSDT",
                    "price": "94067.90000000",
                    "weight": "0.07692308",
                },
            ],
        }

        self.set_mock_response(expected_response)

        response = self.client.query_index_price_constituents(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/constituents" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryIndexPriceConstituentsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryIndexPriceConstituentsResponse, "from_dict")
        ):
            expected = QueryIndexPriceConstituentsResponse.from_dict(expected_response)
        else:
            expected = QueryIndexPriceConstituentsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_index_price_constituents_missing_required_param_symbol(self):
        """Test that query_index_price_constituents() raises RequiredError when 'symbol' is missing."""
        params = {"symbol": "symbol_example"}
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.query_index_price_constituents(**params)

    def test_query_index_price_constituents_server_error(self):
        """Test that query_index_price_constituents() raises an error when the server returns an error."""

        params = {"symbol": "symbol_example"}

        mock_error = Exception("ResponseError")
        self.client.query_index_price_constituents = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_index_price_constituents(**params)

    def test_query_insurance_fund_balance_snapshot_success(self):
        """Test query_insurance_fund_balance_snapshot() successfully with required parameters only."""

        expected_response = {
            "symbols": [
                "BNBUSDT",
                "BTCUSDT",
                "BTCUSDT_250627",
                "BTCUSDT_250926",
                "ETHBTC",
                "ETHUSDT",
                "ETHUSDT_250627",
                "ETHUSDT_250926",
            ],
            "assets": [
                {
                    "asset": "USDC",
                    "marginBalance": "299999998.6497832",
                    "updateTime": 1745366402000,
                },
                {
                    "asset": "USDT",
                    "marginBalance": "793930579.315848",
                    "updateTime": 1745366402000,
                },
                {
                    "asset": "BTC",
                    "marginBalance": "61.73143554",
                    "updateTime": 1745366402000,
                },
                {
                    "asset": "BNFCR",
                    "marginBalance": "633223.99396922",
                    "updateTime": 1745366402000,
                },
            ],
        }

        self.set_mock_response(expected_response)

        response = self.client.query_insurance_fund_balance_snapshot()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/insuranceBalance" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryInsuranceFundBalanceSnapshotResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryInsuranceFundBalanceSnapshotResponse, "from_dict")
        ):
            expected = QueryInsuranceFundBalanceSnapshotResponse.from_dict(
                expected_response
            )
        else:
            expected = QueryInsuranceFundBalanceSnapshotResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_insurance_fund_balance_snapshot_success_with_optional_params(self):
        """Test query_insurance_fund_balance_snapshot() successfully with optional parameters."""

        params = {"symbol": "symbol_example"}

        expected_response = {
            "symbols": [
                "BNBUSDT",
                "BTCUSDT",
                "BTCUSDT_250627",
                "BTCUSDT_250926",
                "ETHBTC",
                "ETHUSDT",
                "ETHUSDT_250627",
                "ETHUSDT_250926",
            ],
            "assets": [
                {
                    "asset": "USDC",
                    "marginBalance": "299999998.6497832",
                    "updateTime": 1745366402000,
                },
                {
                    "asset": "USDT",
                    "marginBalance": "793930579.315848",
                    "updateTime": 1745366402000,
                },
                {
                    "asset": "BTC",
                    "marginBalance": "61.73143554",
                    "updateTime": 1745366402000,
                },
                {
                    "asset": "BNFCR",
                    "marginBalance": "633223.99396922",
                    "updateTime": 1745366402000,
                },
            ],
        }

        self.set_mock_response(expected_response)

        response = self.client.query_insurance_fund_balance_snapshot(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/insuranceBalance" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(QueryInsuranceFundBalanceSnapshotResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(QueryInsuranceFundBalanceSnapshotResponse, "from_dict")
        ):
            expected = QueryInsuranceFundBalanceSnapshotResponse.from_dict(
                expected_response
            )
        else:
            expected = QueryInsuranceFundBalanceSnapshotResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_query_insurance_fund_balance_snapshot_server_error(self):
        """Test that query_insurance_fund_balance_snapshot() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.query_insurance_fund_balance_snapshot = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.query_insurance_fund_balance_snapshot()

    def test_recent_trades_list_success(self):
        """Test recent_trades_list() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
        }

        expected_response = [
            {
                "id": 28457,
                "price": "4.00000100",
                "qty": "12.00000000",
                "quoteQty": "48.00",
                "time": 1499865549590,
                "isBuyerMaker": True,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.recent_trades_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/trades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(RecentTradesListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(RecentTradesListResponse, "from_dict"):
            expected = RecentTradesListResponse.from_dict(expected_response)
        else:
            expected = RecentTradesListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_recent_trades_list_success_with_optional_params(self):
        """Test recent_trades_list() successfully with optional parameters."""

        params = {"symbol": "symbol_example", "limit": 100}

        expected_response = [
            {
                "id": 28457,
                "price": "4.00000100",
                "qty": "12.00000000",
                "quoteQty": "48.00",
                "time": 1499865549590,
                "isBuyerMaker": True,
            }
        ]

        self.set_mock_response(expected_response)

        response = self.client.recent_trades_list(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/trades" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(RecentTradesListResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(RecentTradesListResponse, "from_dict"):
            expected = RecentTradesListResponse.from_dict(expected_response)
        else:
            expected = RecentTradesListResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_recent_trades_list_missing_required_param_symbol(self):
        """Test that recent_trades_list() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.recent_trades_list(**params)

    def test_recent_trades_list_server_error(self):
        """Test that recent_trades_list() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
        }

        mock_error = Exception("ResponseError")
        self.client.recent_trades_list = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.recent_trades_list(**params)

    def test_symbol_order_book_ticker_success(self):
        """Test symbol_order_book_ticker() successfully with required parameters only."""

        expected_response = {
            "symbol": "BTCUSDT",
            "bidPrice": "4.00000000",
            "bidQty": "431.00000000",
            "askPrice": "4.00000200",
            "askQty": "9.00000000",
            "time": 1589437530011,
        }

        self.set_mock_response(expected_response)

        response = self.client.symbol_order_book_ticker()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/ticker/bookTicker" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SymbolOrderBookTickerResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(SymbolOrderBookTickerResponse, "from_dict"):
            expected = SymbolOrderBookTickerResponse.from_dict(expected_response)
        else:
            expected = SymbolOrderBookTickerResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_symbol_order_book_ticker_success_with_optional_params(self):
        """Test symbol_order_book_ticker() successfully with optional parameters."""

        params = {"symbol": "symbol_example"}

        expected_response = {
            "symbol": "BTCUSDT",
            "bidPrice": "4.00000000",
            "bidQty": "431.00000000",
            "askPrice": "4.00000200",
            "askQty": "9.00000000",
            "time": 1589437530011,
        }

        self.set_mock_response(expected_response)

        response = self.client.symbol_order_book_ticker(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/ticker/bookTicker" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SymbolOrderBookTickerResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(SymbolOrderBookTickerResponse, "from_dict"):
            expected = SymbolOrderBookTickerResponse.from_dict(expected_response)
        else:
            expected = SymbolOrderBookTickerResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_symbol_order_book_ticker_server_error(self):
        """Test that symbol_order_book_ticker() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.symbol_order_book_ticker = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.symbol_order_book_ticker()

    def test_symbol_price_ticker_success(self):
        """Test symbol_price_ticker() successfully with required parameters only."""

        expected_response = {
            "symbol": "BTCUSDT",
            "price": "6000.01",
            "time": 1589437530011,
        }

        self.set_mock_response(expected_response)

        response = self.client.symbol_price_ticker()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/ticker/price" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SymbolPriceTickerResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(SymbolPriceTickerResponse, "from_dict"):
            expected = SymbolPriceTickerResponse.from_dict(expected_response)
        else:
            expected = SymbolPriceTickerResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_symbol_price_ticker_success_with_optional_params(self):
        """Test symbol_price_ticker() successfully with optional parameters."""

        params = {"symbol": "symbol_example"}

        expected_response = {
            "symbol": "BTCUSDT",
            "price": "6000.01",
            "time": 1589437530011,
        }

        self.set_mock_response(expected_response)

        response = self.client.symbol_price_ticker(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/ticker/price" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SymbolPriceTickerResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(SymbolPriceTickerResponse, "from_dict"):
            expected = SymbolPriceTickerResponse.from_dict(expected_response)
        else:
            expected = SymbolPriceTickerResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_symbol_price_ticker_server_error(self):
        """Test that symbol_price_ticker() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.symbol_price_ticker = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.symbol_price_ticker()

    def test_symbol_price_ticker_v2_success(self):
        """Test symbol_price_ticker_v2() successfully with required parameters only."""

        expected_response = {
            "symbol": "BTCUSDT",
            "price": "6000.01",
            "time": 1589437530011,
        }

        self.set_mock_response(expected_response)

        response = self.client.symbol_price_ticker_v2()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v2/ticker/price" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SymbolPriceTickerV2Response)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(SymbolPriceTickerV2Response, "from_dict"):
            expected = SymbolPriceTickerV2Response.from_dict(expected_response)
        else:
            expected = SymbolPriceTickerV2Response.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_symbol_price_ticker_v2_success_with_optional_params(self):
        """Test symbol_price_ticker_v2() successfully with optional parameters."""

        params = {"symbol": "symbol_example"}

        expected_response = {
            "symbol": "BTCUSDT",
            "price": "6000.01",
            "time": 1589437530011,
        }

        self.set_mock_response(expected_response)

        response = self.client.symbol_price_ticker_v2(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v2/ticker/price" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(SymbolPriceTickerV2Response)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(SymbolPriceTickerV2Response, "from_dict"):
            expected = SymbolPriceTickerV2Response.from_dict(expected_response)
        else:
            expected = SymbolPriceTickerV2Response.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_symbol_price_ticker_v2_server_error(self):
        """Test that symbol_price_ticker_v2() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.symbol_price_ticker_v2 = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.symbol_price_ticker_v2()

    def test_taker_buy_sell_volume_success(self):
        """Test taker_buy_sell_volume() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "period": TakerBuySellVolumePeriodEnum["PERIOD_5m"].value,
        }

        expected_response = [
            {
                "buySellRatio": "1.5586",
                "buyVol": "387.3300",
                "sellVol": "248.5030",
                "timestamp": "1585614900000",
            },
            {
                "buySellRatio": "1.3104",
                "buyVol": "343.9290",
                "sellVol": "248.5030",
                "timestamp": "1583139900000",
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.taker_buy_sell_volume(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/futures/data/takerlongshortRatio" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"
        assert normalized["period"] == TakerBuySellVolumePeriodEnum["PERIOD_5m"].value

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TakerBuySellVolumeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(TakerBuySellVolumeResponse, "from_dict"):
            expected = TakerBuySellVolumeResponse.from_dict(expected_response)
        else:
            expected = TakerBuySellVolumeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_taker_buy_sell_volume_success_with_optional_params(self):
        """Test taker_buy_sell_volume() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "period": TakerBuySellVolumePeriodEnum["PERIOD_5m"].value,
            "limit": 100,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
        }

        expected_response = [
            {
                "buySellRatio": "1.5586",
                "buyVol": "387.3300",
                "sellVol": "248.5030",
                "timestamp": "1585614900000",
            },
            {
                "buySellRatio": "1.3104",
                "buyVol": "343.9290",
                "sellVol": "248.5030",
                "timestamp": "1583139900000",
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.taker_buy_sell_volume(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/futures/data/takerlongshortRatio" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TakerBuySellVolumeResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif is_oneof or is_list or hasattr(TakerBuySellVolumeResponse, "from_dict"):
            expected = TakerBuySellVolumeResponse.from_dict(expected_response)
        else:
            expected = TakerBuySellVolumeResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_taker_buy_sell_volume_missing_required_param_symbol(self):
        """Test that taker_buy_sell_volume() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "period": TakerBuySellVolumePeriodEnum["PERIOD_5m"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.taker_buy_sell_volume(**params)

    def test_taker_buy_sell_volume_missing_required_param_period(self):
        """Test that taker_buy_sell_volume() raises RequiredError when 'period' is missing."""
        params = {
            "symbol": "symbol_example",
            "period": TakerBuySellVolumePeriodEnum["PERIOD_5m"].value,
        }
        params["period"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'period'"):
            self.client.taker_buy_sell_volume(**params)

    def test_taker_buy_sell_volume_server_error(self):
        """Test that taker_buy_sell_volume() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "period": TakerBuySellVolumePeriodEnum["PERIOD_5m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.taker_buy_sell_volume = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.taker_buy_sell_volume(**params)

    def test_test_connectivity_success(self):
        """Test test_connectivity() successfully with required parameters only."""

        self.set_mock_response({})

        response = self.client.test_connectivity()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/ping" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None

        assert response.data() == {}

    def test_test_connectivity_server_error(self):
        """Test that test_connectivity() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.test_connectivity = MagicMock(side_effect=mock_error)

        with pytest.raises(Exception, match="ResponseError"):
            self.client.test_connectivity()

    def test_ticker24hr_price_change_statistics_success(self):
        """Test ticker24hr_price_change_statistics() successfully with required parameters only."""

        expected_response = {
            "symbol": "BTCUSDT",
            "priceChange": "-94.99999800",
            "priceChangePercent": "-95.960",
            "weightedAvgPrice": "0.29628482",
            "lastPrice": "4.00000200",
            "lastQty": "200.00000000",
            "openPrice": "99.00000000",
            "highPrice": "100.00000000",
            "lowPrice": "0.10000000",
            "volume": "8913.30000000",
            "quoteVolume": "15.30000000",
            "openTime": 1499783499040,
            "closeTime": 1499869899040,
            "firstId": 28385,
            "lastId": 28460,
            "count": 76,
        }

        self.set_mock_response(expected_response)

        response = self.client.ticker24hr_price_change_statistics()

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/fapi/v1/ticker/24hr" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(Ticker24hrPriceChangeStatisticsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(Ticker24hrPriceChangeStatisticsResponse, "from_dict")
        ):
            expected = Ticker24hrPriceChangeStatisticsResponse.from_dict(
                expected_response
            )
        else:
            expected = Ticker24hrPriceChangeStatisticsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_ticker24hr_price_change_statistics_success_with_optional_params(self):
        """Test ticker24hr_price_change_statistics() successfully with optional parameters."""

        params = {"symbol": "symbol_example"}

        expected_response = {
            "symbol": "BTCUSDT",
            "priceChange": "-94.99999800",
            "priceChangePercent": "-95.960",
            "weightedAvgPrice": "0.29628482",
            "lastPrice": "4.00000200",
            "lastQty": "200.00000000",
            "openPrice": "99.00000000",
            "highPrice": "100.00000000",
            "lowPrice": "0.10000000",
            "volume": "8913.30000000",
            "quoteVolume": "15.30000000",
            "openTime": 1499783499040,
            "closeTime": 1499869899040,
            "firstId": 28385,
            "lastId": 28460,
            "count": 76,
        }

        self.set_mock_response(expected_response)

        response = self.client.ticker24hr_price_change_statistics(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/fapi/v1/ticker/24hr" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(Ticker24hrPriceChangeStatisticsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(Ticker24hrPriceChangeStatisticsResponse, "from_dict")
        ):
            expected = Ticker24hrPriceChangeStatisticsResponse.from_dict(
                expected_response
            )
        else:
            expected = Ticker24hrPriceChangeStatisticsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_ticker24hr_price_change_statistics_server_error(self):
        """Test that ticker24hr_price_change_statistics() raises an error when the server returns an error."""

        mock_error = Exception("ResponseError")
        self.client.ticker24hr_price_change_statistics = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.ticker24hr_price_change_statistics()

    def test_top_trader_long_short_ratio_accounts_success(self):
        """Test top_trader_long_short_ratio_accounts() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "period": TopTraderLongShortRatioAccountsPeriodEnum["PERIOD_5m"].value,
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "longShortRatio": "1.8105",
                "longAccount": "0.6442",
                "shortAccount": "0.3558",
                "timestamp": "1583139600000",
            },
            {
                "symbol": "BTCUSDT",
                "longShortRatio": "0.5576",
                "longAccount": "0.3580",
                "shortAccount": "0.6420",
                "timestamp": "1583139900000",
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.top_trader_long_short_ratio_accounts(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/futures/data/topLongShortAccountRatio" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"
        assert (
            normalized["period"]
            == TopTraderLongShortRatioAccountsPeriodEnum["PERIOD_5m"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TopTraderLongShortRatioAccountsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(TopTraderLongShortRatioAccountsResponse, "from_dict")
        ):
            expected = TopTraderLongShortRatioAccountsResponse.from_dict(
                expected_response
            )
        else:
            expected = TopTraderLongShortRatioAccountsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_top_trader_long_short_ratio_accounts_success_with_optional_params(self):
        """Test top_trader_long_short_ratio_accounts() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "period": TopTraderLongShortRatioAccountsPeriodEnum["PERIOD_5m"].value,
            "limit": 100,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "longShortRatio": "1.8105",
                "longAccount": "0.6442",
                "shortAccount": "0.3558",
                "timestamp": "1583139600000",
            },
            {
                "symbol": "BTCUSDT",
                "longShortRatio": "0.5576",
                "longAccount": "0.3580",
                "shortAccount": "0.6420",
                "timestamp": "1583139900000",
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.top_trader_long_short_ratio_accounts(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/futures/data/topLongShortAccountRatio" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TopTraderLongShortRatioAccountsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(TopTraderLongShortRatioAccountsResponse, "from_dict")
        ):
            expected = TopTraderLongShortRatioAccountsResponse.from_dict(
                expected_response
            )
        else:
            expected = TopTraderLongShortRatioAccountsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_top_trader_long_short_ratio_accounts_missing_required_param_symbol(self):
        """Test that top_trader_long_short_ratio_accounts() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "period": TopTraderLongShortRatioAccountsPeriodEnum["PERIOD_5m"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.top_trader_long_short_ratio_accounts(**params)

    def test_top_trader_long_short_ratio_accounts_missing_required_param_period(self):
        """Test that top_trader_long_short_ratio_accounts() raises RequiredError when 'period' is missing."""
        params = {
            "symbol": "symbol_example",
            "period": TopTraderLongShortRatioAccountsPeriodEnum["PERIOD_5m"].value,
        }
        params["period"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'period'"):
            self.client.top_trader_long_short_ratio_accounts(**params)

    def test_top_trader_long_short_ratio_accounts_server_error(self):
        """Test that top_trader_long_short_ratio_accounts() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "period": TopTraderLongShortRatioAccountsPeriodEnum["PERIOD_5m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.top_trader_long_short_ratio_accounts = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.top_trader_long_short_ratio_accounts(**params)

    def test_top_trader_long_short_ratio_positions_success(self):
        """Test top_trader_long_short_ratio_positions() successfully with required parameters only."""

        params = {
            "symbol": "symbol_example",
            "period": TopTraderLongShortRatioPositionsPeriodEnum["PERIOD_5m"].value,
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "longShortRatio": "1.4342",
                "longAccount": "0.5891",
                "shortAccount": "0.4108",
                "timestamp": "1583139600000",
            },
            {
                "symbol": "BTCUSDT",
                "longShortRatio": "1.4337",
                "longAccount": "0.3583",
                "shortAccount": "0.6417",
                "timestamp": "1583139900000",
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.top_trader_long_short_ratio_positions(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs
        parsed_params = parse_qs(request_kwargs["params"])
        camel_case_params = {snake_to_camel(k): v for k, v in params.items()}
        normalized = normalize_query_values(parsed_params, camel_case_params)

        self.mock_session.request.assert_called_once()

        assert "url" in request_kwargs
        assert "/futures/data/topLongShortPositionRatio" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"
        assert normalized["symbol"] == "symbol_example"
        assert (
            normalized["period"]
            == TopTraderLongShortRatioPositionsPeriodEnum["PERIOD_5m"].value
        )

        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TopTraderLongShortRatioPositionsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(TopTraderLongShortRatioPositionsResponse, "from_dict")
        ):
            expected = TopTraderLongShortRatioPositionsResponse.from_dict(
                expected_response
            )
        else:
            expected = TopTraderLongShortRatioPositionsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_top_trader_long_short_ratio_positions_success_with_optional_params(self):
        """Test top_trader_long_short_ratio_positions() successfully with optional parameters."""

        params = {
            "symbol": "symbol_example",
            "period": TopTraderLongShortRatioPositionsPeriodEnum["PERIOD_5m"].value,
            "limit": 100,
            "start_time": 1623319461670,
            "end_time": 1641782889000,
        }

        expected_response = [
            {
                "symbol": "BTCUSDT",
                "longShortRatio": "1.4342",
                "longAccount": "0.5891",
                "shortAccount": "0.4108",
                "timestamp": "1583139600000",
            },
            {
                "symbol": "BTCUSDT",
                "longShortRatio": "1.4337",
                "longAccount": "0.3583",
                "shortAccount": "0.6417",
                "timestamp": "1583139900000",
            },
        ]

        self.set_mock_response(expected_response)

        response = self.client.top_trader_long_short_ratio_positions(**params)

        actual_call_args = self.mock_session.request.call_args
        request_kwargs = actual_call_args.kwargs

        assert "url" in request_kwargs
        assert "/futures/data/topLongShortPositionRatio" in request_kwargs["url"]
        assert request_kwargs["method"] == "GET"

        self.mock_session.request.assert_called_once()
        assert response is not None
        is_list = isinstance(expected_response, list)
        is_flat_list = (
            is_list and not isinstance(expected_response[0], list) if is_list else False
        )
        is_oneof = is_one_of_model(TopTraderLongShortRatioPositionsResponse)

        if is_list and not is_flat_list:
            expected = expected_response
        elif (
            is_oneof
            or is_list
            or hasattr(TopTraderLongShortRatioPositionsResponse, "from_dict")
        ):
            expected = TopTraderLongShortRatioPositionsResponse.from_dict(
                expected_response
            )
        else:
            expected = TopTraderLongShortRatioPositionsResponse.model_validate_json(
                json.dumps(expected_response)
            )

        assert response.data() == expected

    def test_top_trader_long_short_ratio_positions_missing_required_param_symbol(self):
        """Test that top_trader_long_short_ratio_positions() raises RequiredError when 'symbol' is missing."""
        params = {
            "symbol": "symbol_example",
            "period": TopTraderLongShortRatioPositionsPeriodEnum["PERIOD_5m"].value,
        }
        params["symbol"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'symbol'"):
            self.client.top_trader_long_short_ratio_positions(**params)

    def test_top_trader_long_short_ratio_positions_missing_required_param_period(self):
        """Test that top_trader_long_short_ratio_positions() raises RequiredError when 'period' is missing."""
        params = {
            "symbol": "symbol_example",
            "period": TopTraderLongShortRatioPositionsPeriodEnum["PERIOD_5m"].value,
        }
        params["period"] = None

        with pytest.raises(RequiredError, match="Missing required parameter 'period'"):
            self.client.top_trader_long_short_ratio_positions(**params)

    def test_top_trader_long_short_ratio_positions_server_error(self):
        """Test that top_trader_long_short_ratio_positions() raises an error when the server returns an error."""

        params = {
            "symbol": "symbol_example",
            "period": TopTraderLongShortRatioPositionsPeriodEnum["PERIOD_5m"].value,
        }

        mock_error = Exception("ResponseError")
        self.client.top_trader_long_short_ratio_positions = MagicMock(
            side_effect=mock_error
        )

        with pytest.raises(Exception, match="ResponseError"):
            self.client.top_trader_long_short_ratio_positions(**params)
